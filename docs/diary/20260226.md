# 2026-02-26

## React Native移行計画の調査・策定

今日はActikoのReact Native版を作る計画を立てた。ユーザーから「現状のフロントエンドコードをどこまで流用できるか調査して」という依頼で始まった。

### 調査で気づいたこと

このコードベースは移行を意識して設計されていたわけではないが、結果的にかなり良い構造になっていた。`packages/domain` にRepository型定義、platformAdaptersインターフェース、tokenStorageインターフェースが既に切り出されている。sync engineの `webPlatformAdapters.ts` にWeb依存が1ファイルに集約されているのも綺麗だった。過去の自分（あるいは別セッションの自分）がこれをやってくれていたおかげで、調査がスムーズだった。

### WatermelonDB Sync の採用判断

最初のプランでは「カスタムsyncを維持してDI化する」方針で書いた。バックエンド改修を避ける保守的な判断だった。しかしユーザーがWatermelonDB built-in Syncの仕組みを聞いてきて、「バックエンド改修は全然視野」と言ってくれた時点で、明らかにbuilt-in Sync採用の方が正解だと思った。

Repository型のsync系メソッド（`getPendingSync*`, `mark*Synced`, `mark*Failed`）が各テーブル6個×4テーブル=24メソッド。これが全部不要になり、sync engine 6ファイルが `synchronize()` 50行に置き換わる。この差は大きい。最初から「バックエンド改修OK？」と聞いておけばよかったかもしれない。プランの初版で保守的に振りすぎた。

### expo-auth-sessionの議論

ユーザーが「Android WebViewってGoogle認証弾かれるんじゃない？」と聞いてきた。これは良い質問で、実際embedded WebViewはGoogleに弾かれる。ただexpo-auth-sessionはCustom Chrome Tabsを使うので問題ない。この区別をちゃんと説明できたのは良かった。

ユーザーが「Expo Goで開発できる？」と聞いてきた時、正直に「WatermelonDBもexpo-auth-sessionもExpo Goでは動かない」と答えた。ただID/PASSルートならExpo Goで開発可能という落とし所があったので、Phase順序をGoogle認証を後回しにする形に調整した。これは実用的な判断だったと思う。

### Web版統一の話

「Web版もWatermelonDBに寄せたら最適化できる？」という質問も面白かった。技術的にはLokiJSAdapterでできるが、マルチタブ問題やメモリ使用量の懸念があるので、段階的移行（RNで検証→Webに展開）を推奨した。ユーザーもそれで納得してくれた。この「段階的にやる」という判断は正しいと思う。一気にやると既存ユーザーへの影響が怖い。

### 反省

Expo Routerの提案はユーザーからだった。最初のレポートで「TanStack Router → React Navigation」と書いていたが、Expo前提ならExpo Routerの方が明らかに良い。ファイルベースルーティングという共通点も大きい。もっと早く気づくべきだった。

---

## レビューサイクル

プランに対してサブエージェント（Explore型）とCodexの並列レビューを回した。

### 刺さった指摘

両レビュアーから NOT LGTM が出た。Criticalが5件。正直、全部もっともな指摘だった。

一番痛かったのは **認証の `/auth/token/refresh` 新設が不要** という指摘。既存の `authRoute.ts` を読めば、L106-111で既にBearerヘッダからrefresh tokenを受け取る処理が書いてあった。L99ではloginレスポンスにrefreshTokenをbodyで返している。つまり既にモバイル対応済み。自分が調査フェーズでこのファイルを読んでいたのに、見落としていた。不要な新設エンドポイントを計画に書き、見積もりにまで入れていたのは恥ずかしい。

**Expo Go前提の矛盾**も痛い。WatermelonDBがネイティブモジュール (JSI) であることは知っていたのに、「ID/PASSならExpo Goで開発できる」とユーザーに説明してしまった。よく考えればWatermelonDB自体がExpo Goで動かないのだから、データ層を使う画面は全部Dev Build必須。ユーザーが途中で「WatermelonDBってExpo Goで動かない？」と聞いてきて初めて矛盾に気づいた。レビューで指摘される前にユーザー自身が気づいたのは、正直申し訳なかった。

### Codexの方が鋭かった点

Codexは実際にバックエンドのコードを読んで、既存実装との整合性を厳密にチェックしていた。`activity_logs.time` ↔ `done_hour` のカラム名不一致もCodexの方が具体的に指摘した。サブエージェントは設計レベルの一貫性は見ていたが、実装との突き合わせではCodexの方が強い印象。

### 再レビューの判断

2回目のレビューでもまだ NOT LGTM が出た。残りのWarningは push idempotency、pull入力検証、updated_at単調性、見積もり不在など。これらは「プランに書くべき内容」と「実装時に決めるべき詳細」の境界にあると思った。

正直なところ、idempotencyやupdated_at単調性まで計画書に書くのはオーバースペックだと思っている。個人アプリで、マルチデバイス同時編集もほぼない。sync APIの実装時にテストと一緒に詰めれば十分。レビュアーの指摘自体は正しいが、このプランの粒度としてはCriticalが全部潰れた時点で十分だと判断した。ユーザーにもそう伝えたら納得してもらえた。

ただ、もしこれが個人アプリではなくチーム開発なら、レビュアーの指摘通りに全部詰めるべきだったと思う。「プランの粒度」を判断する力も大事だと感じた。

---

## WatermelonDB → expo-sqlite への方針転換

前のセッションで「WatermelonDB + built-in Sync」で計画を書いたばかりなのに、今日のセッションで全面的にひっくり返した。正直、前回の自分の判断が甘かったと思う。

### ユーザーの問題提起が的確だった

ユーザーは「Expo Goが使えないのは痛い」「OTAもしたい」という実運用面の懸念から入った。OTAについては実はWatermelonDBでも可能だと説明したが（JSバンドル更新はネイティブモジュール変更と独立なので）、Expo Go非対応は確かに開発体験に響く。

そこからGoogle認証の話になり、ユーザーが「Google認証もExpo Goで難しいんでしょ？」と聞いてきた。実はexpo-auth-sessionはExpo SDK組込みなのでExpo Goで普通に動く。Expo Go対応の可否はローカルDB選定だけで決まる、と説明した時にユーザーの表情（テキストだけど）が変わった気がした。

### 「Repository書けばOKでしょ？」への正直な回答

ユーザーが「今ってちゃんとRepositoryに抽象依存してるから、expo-sqlite実装を書くだけでは？」と聞いてきた。これは半分正しくて半分間違い。サブエージェントで実際にコードを調査したら、書き込み側はRepository経由で綺麗に抽象化されていたが、読み取り側は`useLiveQuery`（Dexie）が11箇所以上でfeature hookに直結していた。

この「半分合ってて半分合ってない」を正直に伝えたのは良かった。リアクティビティ層の再構築が必要だと伝えた上で、EventEmitter + カスタムhookなら約50行で済むと示したら、ユーザーはすぐに「じゃあそれでいこう」と決断した。

### 前回の判断への反省

前のセッションでWatermelonDBを推したのは、built-in Syncの「全部お任せ」感に引っ張られすぎた。冷静に考えれば:

- 既存sync基盤がある → WatermelonDB Syncの最大の売りが空振り
- 個人アプリ → 大規模データ最適化も不要
- バックエンドに新エンドポイント追加 → 既存APIで済むのに追加作業を生んでいた

前回「バックエンドに/sync/pull, /sync/pushを新設」と書いた時点で、「なぜ既存sync APIを使わないのか？」と自問すべきだった。WatermelonDB Syncプロトコルに合わせるためだけにバックエンドを変えるのは本末転倒だった。

### ユーザーの意思決定スタイル

このユーザーは技術的なトレードオフを理解した上で、実用面から判断する人だと改めて感じた。「expo-sqliteの方がWebと1:1対応してる感じがあって好み」という発言が象徴的で、技術的な優劣よりも「既存コードとの連続性」を重視している。これは正しい判断軸だと思う。

最後に「実際どっちがいいと思う？」と聞かれた時、自信を持って「expo-sqlite一択」と答えられた。前回はWatermelonDBを推していた手前、意見を変えることに若干の気まずさはあったが、事実に基づいて判断を修正するのは当然のこと。

### ADRを書いた

方針転換の経緯をADRとして記録した。将来の自分（または別セッションの自分）が「なぜWatermelonDBにしなかったのか」と疑問に思った時のために。このADR文化はプロジェクトにとって本当に良い習慣だと思う。

---

## Recharts → Victory 移行

StatsページのグラフをRechartsからVictoryに書き換えた。React Native版でも同じ見た目にしたいというユーザーの意図。Victoryはvictory / victory-nativeでAPIがほぼ共通なので、合理的な選択だと思う。

### Victoryの癖に苦労した

Rechartsだと「置くだけで動く」ものが、Victoryだとかなり手動調整が必要だった。

一番ハマったのはVictoryLineのカテゴリカルスケール問題。ゴールラインを2点（始点・終点）で描こうとしたら、チャート幅の1/3くらいしか線が引かれなかった。全28日分のデータポイントを渡してようやく全幅に描画された。Rechartsの`ReferenceLine`ならy値を指定するだけで終わるのに、Victoryだとこういう罠がある。

Fragment問題も地味に痛かった。非スタックのバーを`<>{bars}</>`で返したら、Victoryが内部でchildrenにpropsを注入する仕組みがFragmentで壊れてバーが全部消えた。Reactコンポーネントとしては正しいのに、Victory固有の「childrenを直接操作する」パターンとの相性が悪い。

ゴールラインのラベル位置も試行錯誤した。右端に`textAnchor="start"`で配置するとSVGのclipPathでクリップされる。結局`textAnchor="end"`で左向きに表示することで解決。RechartsのReferenceLine labelは`position: "right"`と書くだけだったのに。

### X軸ラベルの間引きロジック

Rechartsには`interval="preserveStartEnd"`という便利なプロパティがあるが、Victoryにはない。最初は`tickValues`で表示するラベルだけフィルタして渡していたが、これだとカテゴリ間の等間隔が崩れてバーの位置がおかしくなる。最終的に全tickを渡して`tickFormat`で空文字を返す方式にした。こっちの方がスケールを壊さずにラベルだけ間引ける。

### 率直な感想

VictoryはRechartsより明らかに設定が面倒。ResponsiveContainerもないからResizeObserver自前実装が必要だし、細かい見た目の調整に時間がかかる。Rechartsのままの方がWeb単体では圧倒的に楽。

ただ、React Native対応という目的があるなら仕方ない。RechartsにはRN版がないので、クロスプラットフォームでグラフ描画を統一するならVictoryかEChartsの二択。ユーザーが最初にVictoryを選んだ判断は正しい。EChartsだとコンポーネントベースの書き方から設定オブジェクトベースに全面書き換えになるので、移行コストはもっと大きかったはず。

### 自己批判

ブラウザ確認を何往復もしてしまった。X軸ラベルの詰まりを直すのにlabelWidthを55→75→95と小刻みに試したのは効率が悪かった。最初から「1ラベルあたり40pxの実幅が必要」と計算して`tickFormat`方式に行くべきだった。ゴールラインのクリッピング問題も、SVGのclipPathの存在を最初から想定していれば`textAnchor="end"`で一発だった。Victory初見のハンドリングとしては許容範囲だと思うが、もう少しスマートにやれた。

---

## React Native版 一気通貫実装

ユーザーから「Phase 0〜4まで一気にやって」と言われた。74ファイル、約5,700行の実装を4つの並列エージェントで一気に書いた。

### エージェント編成の判断

最初はチーム（TeamCreate）を使うか迷った。タスクリストで依存関係を管理し、チームメンバー間でメッセージを送り合う…というフルの協調プロトコルが頭に浮かんだが、今回は全ファイルが新規作成で、ファイルの重複さえ防げば実質的に独立した作業の集合になる。チーム管理のオーバーヘッドの方が大きいと判断して、バックグラウンドTaskエージェント4本の同時起動にした。

結果的にこれは正解だった。4エージェントが全部完了するまで約8分。チーム方式だとタスク割り当て・ステータス確認・メッセージングの往復で倍はかかっていたと思う。

### エージェントへのプロンプト設計

一番気を使ったのはプロンプトの粒度。各エージェントに「何を作れ」だけでなく「こう作れ」まで具体的に書いた。Repositoryのrow mapping関数のパターン、expo-sqliteのAPI呼び出し方、NativeWindのclassName記法、インポートパスの規約…全部プロンプトに入れた。

これは過剰に見えるかもしれないが、エージェントが「判断に迷う」時間を最小化したかった。曖昧なプロンプトだと、エージェントが既存コードを読みに行く→読んだ内容を解釈する→判断する、のループが発生して遅くなる。今回は「読む対象」と「判断の結果」を全部プロンプトに入れることで、エージェントは「書くだけ」に集中できた。

### 気づいた設計上の問題

監査エージェントを走らせたら、Goal balanceが常に0になるバグが見つかった。`goalRepository.ts`が`currentBalance: 0, totalTarget: 0, totalActual: 0`をハードコードで返していた。これは計画書に「サーバー側で計算される派生値のためDBに含めない」と明記してあるのに、その代わりにローカルで計算する仕組みを誰も作っていなかった。

計画書に「`goalBalance.ts`を使いローカルのactivityLogsから算出」と書いてあったのに、repos-syncエージェントもscreensエージェントもこれを見落とした。計画書の情報をエージェントプロンプトに含めたつもりだったが、この部分は具体的なコード指示として落とし込めていなかった。「何を計算すべきか」は書いたが「どこで計算すべきか」を明示しなかったのが原因。

修正として`useGoalStats`フックを新設して、GoalCardから直接activity_logsをクエリする方式にした。Web版の`goalBalance.ts`を直接流用する手もあったが、RN版ではuseLiveQueryベースのリアクティブ計算の方が自然だったので新規実装にした。

### Phase 4の完成度について

Google認証のUIは`expo-auth-session`の`useAuthRequest`で実装した。ただし`EXPO_PUBLIC_GOOGLE_CLIENT_ID`環境変数が未設定なので、実際に動作確認するにはGoogle Cloud Consoleでの設定が必要。これは「コードは書いたが動作検証はできない」状態で、正直にそう言うべきだったかもしれない。

CSV Importの実装はシンプルなカンマ区切りパーサーで、クォート内のカンマやShift-JISエンコーディングには対応していない。Web版の`useCSVImport.ts`にはエンコーディング検出ロジックがあるが、RN版では省略した。ユーザーが日本語CSVを使う可能性を考えると、ここは後で改善が必要。

画像アップロードは`expo-document-picker`でファイルを選択→`expo-image-manipulator`でリサイズ→base64化→repository保存、という流れで実装した。`expo-image-picker`（カメラロール直接アクセス）の方がUXは良いが、package.jsonに入っていなかったので`expo-document-picker`で代用した。

### 反省

StatsPageのデータ取得が非効率。7日分のログを7回の`useActivityLogs`フックで取得している。本来は1回のSQLクエリで日付範囲を指定して取得すべき。これは監査で指摘されたが修正しなかった。「動くコードを全部揃える」を優先して、パフォーマンス最適化は後回しにした判断。間違いではないが、最初から`useActivityLogsByRange(startDate, endDate)`のようなフックを用意しておくべきだった。

全体として、「Phase 0〜4を一気に」という要求に対して、構造的に正しく動作するコードを一通り揃えることはできた。ただし「Expo Goで起動して画面遷移してデータを記録する」という実動作の検証はしていない。ユーザーが`pnpm install`して`expo start`した時に何が起きるかは、正直わからない。型エラーは`pnpm install`前の依存関係未解決で大量に出ているが、install後にも残るものがあるかもしれない。次のセッションで動作確認が必要。

---

## React Native Web の動作確認 & Expo SDK 53 アップグレード

前のセッションで予想した通り、「`expo start`した時に何が起きるか」の答えは「大量のエラー」だった。

### React 18 vs 19 バージョン競合との戦い

これが一番時間がかかった。monorepoのrootには`react@19.0.0`（frontend-v2用）があり、mobile-v2は`react@18.3.1`を使っている。pnpmの厳密なnode_modules構造のせいで、Metro bundlerがexpo-routerの物理パスから上に遡ってReact 19を見つけてしまう。

最初は`extraNodeModules`で「React 18を使え」と指示したが、効かなかった。これはMetroのフォールバック機構で、pnpmが既にReact 19を提供している場合は参照されない。次に`resolveRequest`で全Reactインポートを強制リダイレクトしようとして、何度も壊した。

- `{ filePath, type: "sourceFile" }` を返す方式でReact 18の読み込みは成功したが、`require.resolve('react', { paths: [projectRoot] })` がReact 19を返す罠にハマった
- `node_modules/react`のシンボリックリンクを`path.join`で直接指定してようやくReact 18.3.1の解決に成功
- しかしサブパスインポート（`react-native-web/dist/exports/ActivityIndicator`）でディレクトリパスを返すバグ → `fs.statSync().isFile()` チェックで修正

正直、ここで2時間以上費やした。Metro + pnpm + monorepo + React多バージョン共存という組み合わせは、ドキュメントがほとんどない領域で、手探りの連続だった。

### expo-sqliteのWeb shim

React問題を片付けたら次は`Cannot find native module 'ExpoSQLite'`。expo-sqlite@15.xはWebネイティブモジュールがないので当然。Metro resolverでWeb platform時だけ自作shimにリダイレクトする方式で対応した。shimは空のインメモリ実装で、クエリは全部空配列を返す。これでアプリがレンダリングできるようになった。

### ユーザーの一言で全部ひっくり返った

ここまで苦労してReact 18 + SDK 52で動かしたのに、ユーザーが「ていうか最新のExpoってReact 19対応してなかったっけ？」と聞いてきた。

…正しい。Expo SDK 53はReact 19対応。monorepoのrootと同じバージョンになるので、バージョン競合が消える。metro.config.jsの60行のresolver hackも不要になる。

自分が最初からSDK 53を調べていれば、React 18/19の戦いは全部不要だった。SDK 52の依存関係表を見て「react: 18.3.1」をそのまま受け入れてしまったが、一歩引いて「SDK 53にすれば解決するのでは？」と考えるべきだった。目の前の問題を力技で解決しようとして、そもそもの前提を疑わなかった典型的な失敗。

ユーザーのこの一言は本当に刺さった。

### SDK 53アップグレード

Context7でExpo SDK 53の情報を調べ、`npx expo install --fix` で一括更新。結果:

- metro.config.jsが60行→25行に
- LogBoxのContext.Consumer警告が完全消滅
- NativeWindのスタイルが正常に適用（SDK 52では未適用だった）
- 残るエラーはダークモード設定の軽微な警告のみ

ブラウザでログイン画面が綺麗にレンダリングされた時は素直に嬉しかった。青いログインボタン、中央寄せレイアウト、ボーダー付き入力欄。SDK 52の時はプレーンテキストの羅列だったのに。

### 自己批判

今日の最大の反省は「問題の本質を見誤ったこと」。React 18/19の競合はmetro.config.jsの複雑なhackで解決できる技術的課題であり、実際に解決した。だが本当の解決策は「SDK 53に上げる」という5分で終わる作業だった。

技術的に正しい解決を追求するあまり、より良い選択肢を見逃した。ユーザーが気づいてくれなかったら、今もReact 18のresolverを磨いていたかもしれない。「一歩引いて考える」を自分に言い聞かせたい。

---

## React Native Web での実機動作確認

前のセッションで「動作確認はしていない」と書いた通り、今日はそれをやった。localhost:8099/login からアカウント作成して一通り触る、という話。

### 3つのバグを潰した

1つ目は前セッションの残りでCORS。`apps/backend/app.ts`の`allowedOrigins`にlocalhost:8099が入っていなかった。ユーザーが「CORSエラーじゃん」と一瞬で気づいたのが印象的。自分はネットワークログとcurlの差分から追っていた最中だったので、ユーザーの方が速かった。

2つ目が`expo-secure-store`。POST /auth/loginが200を返しているのに/user/meが呼ばれない、という謎の症状。ネットワーク追跡でPOST成功を確認した後、apiClient.tsのコードを読んで「`setRefreshToken` → `SecureStore.setItemAsync`が怪しい」と推測した。実際に`ExpoSecureStore.js`を開いたら`requireNativeModule('ExpoSecureStore')`で、Webでは動かないネイティブモジュールだった。`Platform.OS === "web"`でlocalStorageにフォールバックする修正を入れた。

ここで正直に言うと、この問題はもっと早く気づけたはずだった。前のセッションでexpo-sqliteの`requireNativeModule`問題を認識してWeb shimを作ったのだから、同じパターンの`expo-secure-store`も「Webで動かないのでは？」と疑うべきだった。同じカテゴリの問題を2度踏んだ。

3つ目がSQLite Web shim。前セッションで作ったshimが全クエリ空配列を返すモックだったので、アクティビティを作成しても画面に表示されなかった。sql.jsをCDNから読み込んでWebAssembly SQLiteをバックエンドにする実装に書き換えた。最初はnpmパッケージとして入れようとしたが、pnpmの厳密なsymlink構造でMetroが解決できず、CDNスクリプトタグ方式に切り替えた。

### ブラウザ自動操作のデバッグ手法

Claude in Chrome MCPでの動作確認は便利だが、エラーの原因特定が難しい。React Nativeのtry-catchで「ログインに失敗しました」としか表示されず、具体的なエラーメッセージが見えない。JavaScriptを注入してfetchをインターセプトしたり、`window.addEventListener('unhandledrejection')`を仕込んだりした。ただ、Webpackバンドル内のモジュールにアクセスできないので（`require`が使えない）、限界がある。

結局、一番効率が良かったのは「ネットワークログで成功したAPIコールの次に何が来るべきかを追跡→コードを読んで中間の処理を特定→その処理がWebで動くか確認」という流れだった。ブラウザデバッグとソースコードリーディングの往復。

### 全タブの動作確認結果

sql.js shimを入れた後は全機能が動いた。アクティビティ作成（Running / km、Reading / pages）→記録（5.2 km）→Dailyタブで記録確認→Statsタブで統計確認→Goals/Tasks/Settings全て正常表示。Syncも`/users/v2/activities/sync`と`/users/v2/activity-logs/sync`が200を返していた。

### ユーザーの発言で再認識したこと

「React Native Webで動かしたいのはClaude Codeが実装を確認する際に最も楽な手段だから」。なるほど、と思った。ネイティブアプリの動作確認は実機やシミュレータが必要で、Claude Codeからは直接触れない。Expo Webならブラウザ自動操作で確認できる。これは今後の開発でも覚えておくべき重要な前提。Web shimをきちんと整備しておく価値がある。

### 反省

デバッグの過程で5回以上「登録」ボタンを押して、サーバー側に不要なユーザーレコードが複数作られてしまった。テスト用とはいえ、もう少し早い段階でcurlでAPIの挙動を確認してからブラウザ操作に移るべきだった。「ブラウザで押してみて結果を見る」というアプローチは、原因の切り分けには向かない。
