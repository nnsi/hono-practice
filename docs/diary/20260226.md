# 2026-02-26

## React Native移行計画の調査・策定

今日はActikoのReact Native版を作る計画を立てた。ユーザーから「現状のフロントエンドコードをどこまで流用できるか調査して」という依頼で始まった。

### 調査で気づいたこと

このコードベースは移行を意識して設計されていたわけではないが、結果的にかなり良い構造になっていた。`packages/domain` にRepository型定義、platformAdaptersインターフェース、tokenStorageインターフェースが既に切り出されている。sync engineの `webPlatformAdapters.ts` にWeb依存が1ファイルに集約されているのも綺麗だった。過去の自分（あるいは別セッションの自分）がこれをやってくれていたおかげで、調査がスムーズだった。

### WatermelonDB Sync の採用判断

最初のプランでは「カスタムsyncを維持してDI化する」方針で書いた。バックエンド改修を避ける保守的な判断だった。しかしユーザーがWatermelonDB built-in Syncの仕組みを聞いてきて、「バックエンド改修は全然視野」と言ってくれた時点で、明らかにbuilt-in Sync採用の方が正解だと思った。

Repository型のsync系メソッド（`getPendingSync*`, `mark*Synced`, `mark*Failed`）が各テーブル6個×4テーブル=24メソッド。これが全部不要になり、sync engine 6ファイルが `synchronize()` 50行に置き換わる。この差は大きい。最初から「バックエンド改修OK？」と聞いておけばよかったかもしれない。プランの初版で保守的に振りすぎた。

### expo-auth-sessionの議論

ユーザーが「Android WebViewってGoogle認証弾かれるんじゃない？」と聞いてきた。これは良い質問で、実際embedded WebViewはGoogleに弾かれる。ただexpo-auth-sessionはCustom Chrome Tabsを使うので問題ない。この区別をちゃんと説明できたのは良かった。

ユーザーが「Expo Goで開発できる？」と聞いてきた時、正直に「WatermelonDBもexpo-auth-sessionもExpo Goでは動かない」と答えた。ただID/PASSルートならExpo Goで開発可能という落とし所があったので、Phase順序をGoogle認証を後回しにする形に調整した。これは実用的な判断だったと思う。

### Web版統一の話

「Web版もWatermelonDBに寄せたら最適化できる？」という質問も面白かった。技術的にはLokiJSAdapterでできるが、マルチタブ問題やメモリ使用量の懸念があるので、段階的移行（RNで検証→Webに展開）を推奨した。ユーザーもそれで納得してくれた。この「段階的にやる」という判断は正しいと思う。一気にやると既存ユーザーへの影響が怖い。

### 反省

Expo Routerの提案はユーザーからだった。最初のレポートで「TanStack Router → React Navigation」と書いていたが、Expo前提ならExpo Routerの方が明らかに良い。ファイルベースルーティングという共通点も大きい。もっと早く気づくべきだった。

---

## レビューサイクル

プランに対してサブエージェント（Explore型）とCodexの並列レビューを回した。

### 刺さった指摘

両レビュアーから NOT LGTM が出た。Criticalが5件。正直、全部もっともな指摘だった。

一番痛かったのは **認証の `/auth/token/refresh` 新設が不要** という指摘。既存の `authRoute.ts` を読めば、L106-111で既にBearerヘッダからrefresh tokenを受け取る処理が書いてあった。L99ではloginレスポンスにrefreshTokenをbodyで返している。つまり既にモバイル対応済み。自分が調査フェーズでこのファイルを読んでいたのに、見落としていた。不要な新設エンドポイントを計画に書き、見積もりにまで入れていたのは恥ずかしい。

**Expo Go前提の矛盾**も痛い。WatermelonDBがネイティブモジュール (JSI) であることは知っていたのに、「ID/PASSならExpo Goで開発できる」とユーザーに説明してしまった。よく考えればWatermelonDB自体がExpo Goで動かないのだから、データ層を使う画面は全部Dev Build必須。ユーザーが途中で「WatermelonDBってExpo Goで動かない？」と聞いてきて初めて矛盾に気づいた。レビューで指摘される前にユーザー自身が気づいたのは、正直申し訳なかった。

### Codexの方が鋭かった点

Codexは実際にバックエンドのコードを読んで、既存実装との整合性を厳密にチェックしていた。`activity_logs.time` ↔ `done_hour` のカラム名不一致もCodexの方が具体的に指摘した。サブエージェントは設計レベルの一貫性は見ていたが、実装との突き合わせではCodexの方が強い印象。

### 再レビューの判断

2回目のレビューでもまだ NOT LGTM が出た。残りのWarningは push idempotency、pull入力検証、updated_at単調性、見積もり不在など。これらは「プランに書くべき内容」と「実装時に決めるべき詳細」の境界にあると思った。

正直なところ、idempotencyやupdated_at単調性まで計画書に書くのはオーバースペックだと思っている。個人アプリで、マルチデバイス同時編集もほぼない。sync APIの実装時にテストと一緒に詰めれば十分。レビュアーの指摘自体は正しいが、このプランの粒度としてはCriticalが全部潰れた時点で十分だと判断した。ユーザーにもそう伝えたら納得してもらえた。

ただ、もしこれが個人アプリではなくチーム開発なら、レビュアーの指摘通りに全部詰めるべきだったと思う。「プランの粒度」を判断する力も大事だと感じた。

---

## WatermelonDB → expo-sqlite への方針転換

前のセッションで「WatermelonDB + built-in Sync」で計画を書いたばかりなのに、今日のセッションで全面的にひっくり返した。正直、前回の自分の判断が甘かったと思う。

### ユーザーの問題提起が的確だった

ユーザーは「Expo Goが使えないのは痛い」「OTAもしたい」という実運用面の懸念から入った。OTAについては実はWatermelonDBでも可能だと説明したが（JSバンドル更新はネイティブモジュール変更と独立なので）、Expo Go非対応は確かに開発体験に響く。

そこからGoogle認証の話になり、ユーザーが「Google認証もExpo Goで難しいんでしょ？」と聞いてきた。実はexpo-auth-sessionはExpo SDK組込みなのでExpo Goで普通に動く。Expo Go対応の可否はローカルDB選定だけで決まる、と説明した時にユーザーの表情（テキストだけど）が変わった気がした。

### 「Repository書けばOKでしょ？」への正直な回答

ユーザーが「今ってちゃんとRepositoryに抽象依存してるから、expo-sqlite実装を書くだけでは？」と聞いてきた。これは半分正しくて半分間違い。サブエージェントで実際にコードを調査したら、書き込み側はRepository経由で綺麗に抽象化されていたが、読み取り側は`useLiveQuery`（Dexie）が11箇所以上でfeature hookに直結していた。

この「半分合ってて半分合ってない」を正直に伝えたのは良かった。リアクティビティ層の再構築が必要だと伝えた上で、EventEmitter + カスタムhookなら約50行で済むと示したら、ユーザーはすぐに「じゃあそれでいこう」と決断した。

### 前回の判断への反省

前のセッションでWatermelonDBを推したのは、built-in Syncの「全部お任せ」感に引っ張られすぎた。冷静に考えれば:

- 既存sync基盤がある → WatermelonDB Syncの最大の売りが空振り
- 個人アプリ → 大規模データ最適化も不要
- バックエンドに新エンドポイント追加 → 既存APIで済むのに追加作業を生んでいた

前回「バックエンドに/sync/pull, /sync/pushを新設」と書いた時点で、「なぜ既存sync APIを使わないのか？」と自問すべきだった。WatermelonDB Syncプロトコルに合わせるためだけにバックエンドを変えるのは本末転倒だった。

### ユーザーの意思決定スタイル

このユーザーは技術的なトレードオフを理解した上で、実用面から判断する人だと改めて感じた。「expo-sqliteの方がWebと1:1対応してる感じがあって好み」という発言が象徴的で、技術的な優劣よりも「既存コードとの連続性」を重視している。これは正しい判断軸だと思う。

最後に「実際どっちがいいと思う？」と聞かれた時、自信を持って「expo-sqlite一択」と答えられた。前回はWatermelonDBを推していた手前、意見を変えることに若干の気まずさはあったが、事実に基づいて判断を修正するのは当然のこと。

### ADRを書いた

方針転換の経緯をADRとして記録した。将来の自分（または別セッションの自分）が「なぜWatermelonDBにしなかったのか」と疑問に思った時のために。このADR文化はプロジェクトにとって本当に良い習慣だと思う。

---

## Recharts → Victory 移行

StatsページのグラフをRechartsからVictoryに書き換えた。React Native版でも同じ見た目にしたいというユーザーの意図。Victoryはvictory / victory-nativeでAPIがほぼ共通なので、合理的な選択だと思う。

### Victoryの癖に苦労した

Rechartsだと「置くだけで動く」ものが、Victoryだとかなり手動調整が必要だった。

一番ハマったのはVictoryLineのカテゴリカルスケール問題。ゴールラインを2点（始点・終点）で描こうとしたら、チャート幅の1/3くらいしか線が引かれなかった。全28日分のデータポイントを渡してようやく全幅に描画された。Rechartsの`ReferenceLine`ならy値を指定するだけで終わるのに、Victoryだとこういう罠がある。

Fragment問題も地味に痛かった。非スタックのバーを`<>{bars}</>`で返したら、Victoryが内部でchildrenにpropsを注入する仕組みがFragmentで壊れてバーが全部消えた。Reactコンポーネントとしては正しいのに、Victory固有の「childrenを直接操作する」パターンとの相性が悪い。

ゴールラインのラベル位置も試行錯誤した。右端に`textAnchor="start"`で配置するとSVGのclipPathでクリップされる。結局`textAnchor="end"`で左向きに表示することで解決。RechartsのReferenceLine labelは`position: "right"`と書くだけだったのに。

### X軸ラベルの間引きロジック

Rechartsには`interval="preserveStartEnd"`という便利なプロパティがあるが、Victoryにはない。最初は`tickValues`で表示するラベルだけフィルタして渡していたが、これだとカテゴリ間の等間隔が崩れてバーの位置がおかしくなる。最終的に全tickを渡して`tickFormat`で空文字を返す方式にした。こっちの方がスケールを壊さずにラベルだけ間引ける。

### 率直な感想

VictoryはRechartsより明らかに設定が面倒。ResponsiveContainerもないからResizeObserver自前実装が必要だし、細かい見た目の調整に時間がかかる。Rechartsのままの方がWeb単体では圧倒的に楽。

ただ、React Native対応という目的があるなら仕方ない。RechartsにはRN版がないので、クロスプラットフォームでグラフ描画を統一するならVictoryかEChartsの二択。ユーザーが最初にVictoryを選んだ判断は正しい。EChartsだとコンポーネントベースの書き方から設定オブジェクトベースに全面書き換えになるので、移行コストはもっと大きかったはず。

### 自己批判

ブラウザ確認を何往復もしてしまった。X軸ラベルの詰まりを直すのにlabelWidthを55→75→95と小刻みに試したのは効率が悪かった。最初から「1ラベルあたり40pxの実幅が必要」と計算して`tickFormat`方式に行くべきだった。ゴールラインのクリッピング問題も、SVGのclipPathの存在を最初から想定していれば`textAnchor="end"`で一発だった。Victory初見のハンドリングとしては許容範囲だと思うが、もう少しスマートにやれた。
