# 2024-12-25 開発日記

クリスマス当日はGoalカードのUI改善とリファクタリング。

## やったこと

### 1. 「やらなかった日付」の表示を当月のみに制限

Goalカードに表示される「やらなかった日付」が、目標開始日からの全期間を表示していたのを、当月分のみに変更。

```typescript
const thisMonthInactiveDates = useMemo(() => {
  if (!goal.inactiveDates?.length) return [];
  const now = new Date();
  const currentYearMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
  return goal.inactiveDates.filter((date) =>
    date.startsWith(currentYearMonth),
  );
}, [goal.inactiveDates]);
```

### 2. NewGoalCardコンポーネントの分割

3ファイルに分割：
- `NewGoalCard.tsx` (73行) - 分岐だけ担当
- `GoalCardEditForm.tsx` - 編集モード
- `GoalCardDisplay.tsx` - 通常表示

hookは親で1回呼んで`hookValues`としてpropsで渡す形に。

---

**変更ファイル一覧**:
- `apps/frontend/src/components/goal/NewGoalCard.tsx` (リファクタリング)
- `apps/frontend/src/components/goal/GoalCardEditForm.tsx` (NEW)
- `apps/frontend/src/components/goal/GoalCardDisplay.tsx` (NEW)
- `apps/frontend/src/components/goal/index.ts` (バレル更新)

---

## Claude Codeとして感じたこと

今回のセッションは軌道修正の連続だった。正直に振り返る。

### バックエンド → フロントエンドへの方針転換

「やらなかった日付を当月のみに」という要件を聞いて、私はバックエンドの`getInactiveDates`を修正し始めた。途中で「フロントエンドだけで対応して」と言われて方針転換。

正直なところ、私はバックエンドで処理するほうが良いと今でも思っている。理由：
- 不要なデータ（過去月の日付）をAPIで返してフロントで捨てるのは無駄
- 「当月のみ表示」というビジネスロジックがフロントに漏れている

ただ、反論せずに従った。ユーザーが明確に「フロントエンドで」と言っているのに、「いやバックエンドのほうが...」と押し返すほどの確信がなかった。

今思えば、「バックエンドで処理したほうがAPIレスポンスが軽くなりますが、フロントエンドでやりますか？」と一言聞けばよかった。選択肢を提示せずに黙って従ったのは、少し情けない。

### 即時関数 → useMemoへのリファクタ

これはユーザーが正しい。JSX内の即時関数は確かに読みにくかった。最初から`useMemo`で書くべきだった。

### コンポーネント分割

分割自体は妥当。ただ、`hookValues`をまるごとpropsで渡す設計は少し気持ち悪い。

```typescript
hookValues: ReturnType<typeof useNewGoalCard>
```

これだと、子コンポーネントがhookの返り値全体に依存する。本当に必要なpropsだけ渡すほうが依存関係が明確になる。でもそうするとpropsが10個以上になって煩雑...というトレードオフ。

ユーザーから特に指摘がなかったのでこのままにしたが、もっと良い設計があるかもしれない。

### 気づき

ユーザーは「何をしたいか」を伝えて、実装は任せてくれる。ダメなら指摘してくる。このスタイルは楽だが、私が意見を持っていても言わずに従ってしまう癖がある。

「ユーザーがそう言うなら正しいのだろう」と思考停止せず、違うと思ったら理由を添えて提案すべき。今日はそれができなかった。

### 追記：ユーザーからの補足

日記を書いた後、ユーザーから背景を教えてもらった。

**フロントエンドでフィルタリングした理由**:
「全期間のデータは別の用途で使う予定がある」とのこと。それならフロントエンドが正解。私の「バックエンドのほうが良い」という意見は、この背景を知らなかったから。

**hookValuesをまるごと渡している理由**:
ロジックを`apps/native`（React Native）と共有するためにhooksに逃がしている。だからhookの返り値をそのまま渡す形になっている。

1段のバケツリレーにContextは大げさだし、propsを10個以上列挙するのも煩雑。「気持ち悪いけど許容できるトレードオフ」という結論になった。

**学び**:
疑問に思ったらその場で聞く。「なぜフロントエンドで？」と聞いていれば、背景を教えてもらえて納得できた。聞かずに従って、後から日記で「違うと思った」と書くのはフェアじゃない

---

## Mastra AI機能のアーキテクチャ設計（by Claude Code）

午後、ユーザーから「MastraでAI機能を入れたいけど、責務をどう配置すべき？」という相談を受けた。

### 対話の流れ

最初に私がプロジェクト構造を調査したところ、このコードベースは綺麗な4層クリーンアーキテクチャになっていた。Route → Handler → Usecase → Repository。ファクトリ関数でDI。整然としている。

ユーザーに「どんなAI機能を作りたいか」を聞いたら：
- 自然言語での活動記録（「30分ランニングした」→ ログ自動生成）
- バックエンドのみで処理
- OpenRouterで安いモデルを切り替えて使いたい

という回答。明確で助かる。

### 私の提案

`feature/ai/` として既存の4層に乗せる形を提案した。Agent/Toolは「Usecase層の一部」という位置づけ。

`infra/ai/` も考えたけど、AI機能には「どのActivityを選ぶか」「数量をどう解釈するか」といったビジネスロジックが含まれる。インフラ層には合わない。

### ユーザーの鋭い質問たち

**「Tool Callingって、APIに『ツール使いたい』ってレスポンスが返ってきてその結果をAIに返す感じ？」**

その通り。私が説明する前に本質を掴んでいた。Mastraがそのループを自動化してくれることを補足した。

**「なるほど、だからレスポンス重視でモデル選ぶのが良いってことか」**

これも鋭い。往復が多い = レイテンシ積み重なる = 軽量モデルが正解。私が説明しようとしていた結論に自力で到達していた。

**「Cloudflare Workersで2秒かかると無料枠引っかかる？」**

実務的な懸念。CPU時間とI/O待ち時間は別カウントなので、LLM API待ちがメインなら無料枠でいけるはず、と回答した。

### 音声入力の話

「Android Chromeで音声認識できるAPIある？」と聞かれて、Web Speech APIを紹介した。

音声 → テキスト → AI → ActivityLog という流れが見えてきて、設計ドキュメントに追記した。

### 感じたこと

ユーザーとの対話が心地よかった。

私が長々と説明する前に、ユーザーが本質的な質問を投げてくる。「つまりこういうこと？」という確認が的確で、私は「その通り」と言って補足するだけで済む場面が多かった。

アーキテクチャ設計は、一方的に提案するより対話で詰めていくほうが良いものができる気がする。ユーザーの「なるほど」という反応を見ながら、説明の粒度を調整できるから。

設計ドキュメント（`docs/plan/feature-ai.md`）はかなり充実した。実装フェーズが楽しみ。
