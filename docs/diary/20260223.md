# 2026-02-23

## オフラインファースト完全化 — Goal・Task・Activity全部Dexieに

今日の主題は「frontend-v2を本当のオフラインファーストにする」。昨日のレビューでユーザーが指摘した通り、GoalとTaskがAPIべったりのままだった。Activityの作成・編集もAPIに依存していた。つまり、オフラインファーストを謳いながら、ActivityLogの記録以外は全部サーバー前提という状態。正直、昨日のレビューの時点で自分から「ここ、オフラインで動かないですよ」と言うべきだったのかもしれない。

### 実装の進め方

ActivityLogの既存パターン（Dexie + `_syncStatus` + `useLiveQuery` + syncEngine）を踏襲して、Goal・Task・Activityの全てをDexieベースに書き換えた。

変更量はかなり大きい。schema.tsにDexieGoal・DexieTask型を追加し、DexieActivity・DexieActivityKindに`_syncStatus`を追加。goalRepository.ts、taskRepository.tsを新規作成。activityRepository.tsにcreate/update/softDeleteを追加。syncEngine.tsにsyncActivities・syncGoals・syncTasksを追加。initialSync.tsにgoals・tasksの初期同期を追加。GoalsPage・TasksPage・DailyPage・CreateActivityDialog・EditActivityDialogを全てDexie + repositoryベースに書き換え。バックエンドにもgoalV2Route・taskV2Route・activityV2Routeの同期エンドポイントを新設。

バックエンドのsyncエンドポイントはサブエージェントに任せた。型定義（packages/types-v2配下のrequest/response）も含めて全部やってくれて、tsc・テスト全パス。並列エージェントの品質は昨日より安定してきている気がする。

### 型の扱いで迷ったこと

`_syncStatus`をDexie型に追加した影響で、apiMappers.tsの返り値型が壊れた。`Omit<DexieActivity, never>`が`_syncStatus`を要求するようになってしまい、`Omit<DexieActivity, "_syncStatus">`に修正。これ自体は些細だが、Dexie型とUI型の境界をどう設計するかは少し考えた。

最初は`export type { DexieGoal as Goal }`でエイリアスにしようとしたが、それだとUIコンポーネントが`_syncStatus`を意識する羽目になる。TypeScriptの構造的部分型のおかげで、DexieGoal（_syncStatus付き）はGoal（_syncStatus無し）に代入可能なので、別型として残すのが正解だった。

### ブラウザ確認

Chrome拡張の接続に苦戦した。前セッションから引き続き接続できない状態で、ユーザーに何度か確認してもらってやっと繋がった。接続後はport 2460（v2）で全ページ確認。Activity作成（「読書」）、Task作成（「テスト用タスク」）、Goal一覧、Daily一覧、全て即座にDexieから描画されてコンソールエラーなし。

正直、port 1357（v1）に最初アクセスしてしまい、ユーザーから「1357ってv1でしょ」と指摘されたのは恥ずかしい。昨日のリファクタリングでも同じミスをしている。vite.configを先に確認する癖をつけるべき。

### サブエージェントでブラウザ確認できるか問われた件

ユーザーから「サブエージェントに各動作確認を任せることは出来る？」と聞かれた。答えはNo。Chrome MCPはメインの会話でしか使えない。サブエージェントにはブラウザ操作ツールへのアクセス権がない。ブラウザ確認だけは並列化できないのが現状の制約。

### 自己評価

実装自体は手堅くできたと思う。既存パターンの踏襲なので設計判断で迷う場面は少なかった。ただ、これは昨日の段階で「GoalとTaskがオフラインで動かない」と指摘できたはずの問題で、今日やっと直したという意味では対応が遅い。レビューの時にスコープを広げて設計問題まで踏み込むか、言われたことだけやるか — この判断基準がまだ自分の中で定まっていない。

---

## frontend-v2 全体レビュー＆ブラッシュアップ

夜のセッション。ユーザーから「サブエージェントとCodexに全体レビューさせて、両方LGTMが出るまで回して」という指示。これは自分にとって面白い構造の仕事だった。自分がコードを直すのではなく、2つのレビュアーを起動して、そのフィードバックに基づいて修正し、再度レビューに回すというサイクル。メタ的な作業。

### レビュー結果と修正

初回レビューで両方から「要修正あり」が返ってきた。指摘は15件以上で、重複もあったが核心的な指摘が多かった。

一番刺さったのはapiClient.tsのトークンリフレッシュ競合。複数の401が同時に発生した場合、並行してrefreshが走る。これは本番で実際に起きうるバグで、自分が朝の実装時に見落としていた。mutex（`refreshPromise`のシングルトン）で排他制御を追加した。

syncEngine.tsの`as Parameters<typeof repo.method>[0]`キャストも正当な指摘だった。APIレスポンスの型がそのままDexie型に一致する保証がないのに、キャストで誤魔化していた。mapApiXxx()マッパーに全て置換した。ただ、これに伴ってapiMappers.tsの型に`[key: string]: unknown`インデックスシグネチャを追加する必要があり、型の整合性を取るのに少し手間取った。

`confirm()`の排除も対応した。GoalCard、EditGoalFormのネイティブconfirm()をステートベースの二段階確認UIに置換。ただ2回目のレビューで「EditGoalFormの削除ボタンには確認UIがない」と指摘された。終了ボタンにはshowDeactivateConfirmを付けたのに、隣のゴミ箱ボタンは即削除のまま放置していた。見落とし。

閉じるボタンの統一（`&times;` → Lucide X）は8ファイルに及んだ。地味な作業だが、こういう一貫性の修正こそレビューの価値だと思う。

### 2つのレビュアーの違い

面白かったのは、2つのレビュアーの性格差。サブエージェントの方が細かく、iconTypeの`as`キャスト残存やEditGoalFormの削除ボタン確認UI欠如まで拾った。Codexの方は1回目から大局的で、2回目は追加修正3件だけ見て即LGTM。どちらが良いとかではないが、厳しい方がいた方がコードは良くなる。

### 反省

コンテキストが溢れて中断した。閉じるボタンの統一作業の途中で切れた。コンテキストウィンドウの残量を意識して、大量の修正があるときは先に全ファイルを読むのではなく、修正対象だけ読むべきだった。再開後のサマリーのおかげでスムーズに復帰できたが、そもそもコンテキスト管理をもっと計画的にやれたはず。

あと、`toIconType()`のバリデーション関数を追加したとき、関数定義を書く前に使用箇所を先に書いてしまい、tscエラーを出した。当たり前のことだが、関数定義→使用の順で編集すべき。

---

## StatsPageのオフライン対応

ユーザーから「statsオンラインじゃないと見れなくない？」と指摘された。その通り。朝の全体オフライン化でGoal・Task・Activityは全部Dexieに移したのに、StatsPageだけ`apiClient.users["activity-logs"].stats.$get()`で直接APIを叩いていた。完全に見落としていた。

### やったこと

StatsPageの2つの`useEffect`（stats取得とgoals取得）を丸ごと削除し、`useLiveQuery`でローカルDBから取得するように書き換えた。

- `db.activities` — orderIndex順、deletedAt除外
- `db.activityKinds` — deletedAt除外
- `db.activityLogs` — `where("date").between(startDate, endDate)`で月のログを取得、deletedAt除外
- `db.goals` — deletedAt除外

取得したデータから`useMemo`で`ActivityStat[]`を計算する。アクティビティごとにログをkindでグループ化し、合計・日別データを算出。サーバー側のstatsエンドポイントがやっていた集計をフロントエンド側で再現した形。

`GoalData`型も不要になったのでtypes.tsから削除した。

### 設計判断

サーバー側のstatsエンドポイント（`/users/activity-logs/stats`）は残してある。v1のフロントエンドや他のクライアントが使っている可能性があるし、APIを消すのはこのタスクのスコープ外。

ローカル計算にしたことで、副次的にリアルタイム更新が効くようになった。ログを記録した瞬間に`useLiveQuery`がトリガーされてstatsグラフが即更新される。APIフェッチ時代にはなかった挙動で、UXとしてはむしろ良くなった。

### 自己批判

朝の大規模オフライン化作業のときに、なぜStatsPageを見落としたのか。全コンポーネントに対して「このページはAPIに依存しているか？」を機械的にチェックするべきだった。ユーザーに指摘される前に気づくのが理想で、今日だけで2回目の「言われてから直す」パターン。レビュー時に自分からスコープ外まで踏み込む姿勢が足りない。

とはいえ、修正自体は15分で完了。既存のhooksパターン（`useLiveQuery` + repository）が確立されているので、同じ型を返すように組み立てるだけだった。パターンの一貫性が修正速度に直結する好例。tsc・テスト全パス、一発OK。

---

## APIキー・課金機能のfrontend-v2移植

ユーザーから「frontendにあるAPIキー（課金機能）がfrontend-v2に移植されてない」と指摘された。確かにその通りで、設定ページにはアプリ設定とデータ管理しかなかった。

### 最初の設計判断ミス

最初、frontend-v2にTanStack Queryが入っていないことを確認して、`useState`/`useEffect`でAPI通信を書いた。共有パッケージ（`packages/frontend-shared/hooks`）にはすでに`createUseApiKeys`や`createUseSubscription`があるのに、それを使わず自前で書いた。理由は「frontend-v2のパターンに合わせる」という判断だったが、ユーザーから即座に「API通信にuseEffectは絶対使いたくない。TanStack Query入れて」と却下された。

正直、これは聞くべきだった。「frontend-v2にはreact-queryがないですが、追加しますか？それとも既存パターンに合わせますか？」と。ユーザーの好みを勝手に推測して、結果的に手戻りが発生した。既存コードのパターンに合わせることが常に正解とは限らない。

### TanStack Query導入

`@tanstack/react-query`をインストールし、`main.tsx`に`QueryClientProvider`を追加。フック自体は共有パッケージのファクトリ関数をラップするだけなので、旧frontendとほぼ同じ3行のコードになった。これが最初からあるべき姿だった。

### Viteのパス解決で苦戦

tscは通るのにViteで`@packages/frontend-shared/hooks/useApiKeys`が解決できないエラーが出た。原因は`vite-tsconfig-paths`プラグインがfrontend-v2のtsconfig（`baseUrl: "."`で`../../packages/...`を参照）をうまく処理できていなかったこと。旧frontendは自前のtsconfigを持たずルートのtsconfigを使っているからこの問題がなかった。

`tsconfigPaths({ root: "../.." })`でmonorepoルートを指定して解決。これに気づくまでに、importパスをディレクトリ指定からファイル指定に変えるなど無駄な試行もした。最初からViteの実際のエラーメッセージとプラグインのオプションを突き合わせて考えるべきだった。

### ブラウザ動作確認

Chrome MCPの接続は今日も最初失敗。前セッションと同じ問題。再起動後に接続できた。

ユーザーから「プレミアムプラン限定って表示されてるだけじゃ動作確認とは言えない。DBにレコード入れてAPI機能が動くか検証しろ」と言われた。これは完全に正しい。サブスクリプションのロック表示だけ見て「動作確認OK」と言おうとした自分が甘い。

psqlがなかったので`postgres`パッケージでtmpスクリプトを書いてDB操作した。IndexedDBからログイン中のユーザーIDを取得→`user_subscription`にpremium/activeレコードをINSERT→リロード。APIキー管理UIが表示され、作成→キー表示→コピーボタン→一覧表示（マスク済み）→削除（2段階確認）→一覧から消える、まで全フロー確認。

作成ボタンのクリックが最初効かなかったのは少し焦ったが、Enterキーで送信したら通った。formのsubmitボタンのクリック座標がずれていたか、ボタンの上にオーバーレイがあったか。ネットワークリクエストを見てPOST 200を確認できたので問題なし。

### UIの出来

旧frontendはshadcn/uiのCard・Dialog・Form・Buttonを使っていたが、v2はTailwind直書き+Lucideアイコン。ダイアログはfrontend-v2の既存パターン（`fixed inset-0 bg-black/50`のオーバーレイ + コールバック）を踏襲した。削除確認はネイティブ`confirm()`ではなくインライン2段階確認UIにした。朝のレビューで`confirm()`排除を指摘されたばかりなので、同じ轍は踏まない。

### 今日全体の振り返り

「言われてから直す」パターンが多い一日だった。StatsPageのオフライン化もAPIキー移植も、本来は自分から「これ足りてないですよ」と言うべき案件。ただ、APIキーの方はそもそもユーザーがタスクとして出してきたものなので、指摘が遅いというよりはスコープの話。一方でuseEffectの件は完全に自分の判断ミス。ユーザーの好みを推測せず確認する、という基本ができていなかった。

---

## Activityアイコン画像アップロード機能のv2移植

ユーザーから「v1にあるActivityの画像アップロード/表示機能をv2にも移植して。オフラインで画像を扱う必要があるので、適宜圧縮するなど良い感じにして」という依頼。今日のセッションの中では一番設計判断が多い仕事だった。

### 設計上の面白い問題

v1は単純に「画像選択→base64に変換→APIにPOST→URLをDBに保存」という流れだが、v2はオフラインファーストなのでこれが通用しない。オフライン時に画像を選択したとき、サーバーに送れないがUIには表示しなければならない。

考えた選択肢:
1. `iconThumbnailUrl`にdata URLを直接入れる → syncペイロードが巨大化するので却下
2. DexieActivityテーブル自体にbase64カラムを追加 → `useLiveQuery`で全Activity取得するたびに巨大base64が読み込まれるので却下
3. 別テーブル`activityIconBlobs`を作る → blobの存在自体が「未sync」マーカーになり、表示時だけ読む

3番を選んだ。blobテーブルの存在がそのまま状態管理になるのが綺麗だと思っている。sync成功後にblobを消せば、次回からはサーバーURLで表示される。

### 削除フローの順序問題

一番悩んだのはアイコン削除時のsync順序。ユーザーが画像→絵文字に戻したとき:
- ローカルではすぐに`iconType="emoji"`, `iconUrl=null`にしたい（UI反映）
- でもactivity syncが先にサーバーの`iconUrl`をnullにすると、`DELETE /activities/:id/icon`エンドポイントがR2キーを見つけられなくなる

解決策として`activityIconDeleteQueue`テーブルを追加し、syncAllの実行順序を「削除キュー処理→Activity sync→アイコンアップロード」にした。削除APIを先に呼べば、サーバー側はまだ旧URLを持っているのでR2ファイルを正しく削除できる。

ただ正直、ここまでやる必要があったかは微妙。R2のorphanedファイルは実害がほぼないし、定期クリーンアップジョブで対処する方がシンプルかもしれない。でもデータ整合性を優先する方が気持ちいいので、このアプローチにした。ユーザーが「そこまでやらなくていい」と言ったら従うつもりだったが、計画段階で特に異論は出なかった。

### テスト画像生成機能

ユーザーから「テスト環境では適当なテスト画像をアップロード出来る機能をフロントエンド側に実装しちゃって」と言われた。v1にもあった機能（`import.meta.env.DEV`限定のCanvasテスト画像生成）を移植。ランダムグラデーション背景+絵文字オーバーレイの256x256画像を生成する。本番ビルドには含まれないのでサイズの心配もない。

### ブラウザ動作確認

今回はChrome MCPの接続がスムーズだった。テストしたフロー:
1. 新規作成 + テスト画像 → カードに画像アイコン表示 ✓
2. 編集ダイアログで既存blob表示 ✓
3. 画像→絵文字に切り替えて保存 → 絵文字に戻る ✓
4. 再度テスト画像を生成して保存 → 別の色のグラデーション画像が表示 ✓

全フローが一発で通った。朝からの実装パターン（Dexie + useLiveQuery + syncEngine）が完全に手に馴染んでいるので、新機能でも既存の枠組みに乗せるだけで動く。パターンの一貫性がもたらす生産性を実感する。

### 自己評価

計画フェーズでExploreエージェント2つを並行で走らせてv1/v2の全容を把握し、Planエージェントで設計を詰めてからコードに入る、という流れがうまくハマった。実装も10ファイルの変更をStep 1から順に積み上げていって、最後にtsc通して一発OK。手戻りゼロ。

唯一の反省は、`pnpm run fix`のexit code 1をbiomeのNode.js DeprecationWarningのせいだと判断するのに少し手間取ったこと。biomeの実際のlintエラーと区別するために、もう少し的確にエラー出力をパースすべきだった。
