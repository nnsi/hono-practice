# 2026-02-23

## オフラインファースト完全化 — Goal・Task・Activity全部Dexieに

今日の主題は「frontend-v2を本当のオフラインファーストにする」。昨日のレビューでユーザーが指摘した通り、GoalとTaskがAPIべったりのままだった。Activityの作成・編集もAPIに依存していた。つまり、オフラインファーストを謳いながら、ActivityLogの記録以外は全部サーバー前提という状態。正直、昨日のレビューの時点で自分から「ここ、オフラインで動かないですよ」と言うべきだったのかもしれない。

### 実装の進め方

ActivityLogの既存パターン（Dexie + `_syncStatus` + `useLiveQuery` + syncEngine）を踏襲して、Goal・Task・Activityの全てをDexieベースに書き換えた。

変更量はかなり大きい。schema.tsにDexieGoal・DexieTask型を追加し、DexieActivity・DexieActivityKindに`_syncStatus`を追加。goalRepository.ts、taskRepository.tsを新規作成。activityRepository.tsにcreate/update/softDeleteを追加。syncEngine.tsにsyncActivities・syncGoals・syncTasksを追加。initialSync.tsにgoals・tasksの初期同期を追加。GoalsPage・TasksPage・DailyPage・CreateActivityDialog・EditActivityDialogを全てDexie + repositoryベースに書き換え。バックエンドにもgoalV2Route・taskV2Route・activityV2Routeの同期エンドポイントを新設。

バックエンドのsyncエンドポイントはサブエージェントに任せた。型定義（packages/types-v2配下のrequest/response）も含めて全部やってくれて、tsc・テスト全パス。並列エージェントの品質は昨日より安定してきている気がする。

### 型の扱いで迷ったこと

`_syncStatus`をDexie型に追加した影響で、apiMappers.tsの返り値型が壊れた。`Omit<DexieActivity, never>`が`_syncStatus`を要求するようになってしまい、`Omit<DexieActivity, "_syncStatus">`に修正。これ自体は些細だが、Dexie型とUI型の境界をどう設計するかは少し考えた。

最初は`export type { DexieGoal as Goal }`でエイリアスにしようとしたが、それだとUIコンポーネントが`_syncStatus`を意識する羽目になる。TypeScriptの構造的部分型のおかげで、DexieGoal（_syncStatus付き）はGoal（_syncStatus無し）に代入可能なので、別型として残すのが正解だった。

### ブラウザ確認

Chrome拡張の接続に苦戦した。前セッションから引き続き接続できない状態で、ユーザーに何度か確認してもらってやっと繋がった。接続後はport 2460（v2）で全ページ確認。Activity作成（「読書」）、Task作成（「テスト用タスク」）、Goal一覧、Daily一覧、全て即座にDexieから描画されてコンソールエラーなし。

正直、port 1357（v1）に最初アクセスしてしまい、ユーザーから「1357ってv1でしょ」と指摘されたのは恥ずかしい。昨日のリファクタリングでも同じミスをしている。vite.configを先に確認する癖をつけるべき。

### サブエージェントでブラウザ確認できるか問われた件

ユーザーから「サブエージェントに各動作確認を任せることは出来る？」と聞かれた。答えはNo。Chrome MCPはメインの会話でしか使えない。サブエージェントにはブラウザ操作ツールへのアクセス権がない。ブラウザ確認だけは並列化できないのが現状の制約。

### 自己評価

実装自体は手堅くできたと思う。既存パターンの踏襲なので設計判断で迷う場面は少なかった。ただ、これは昨日の段階で「GoalとTaskがオフラインで動かない」と指摘できたはずの問題で、今日やっと直したという意味では対応が遅い。レビューの時にスコープを広げて設計問題まで踏み込むか、言われたことだけやるか — この判断基準がまだ自分の中で定まっていない。

---

## frontend-v2 全体レビュー＆ブラッシュアップ

夜のセッション。ユーザーから「サブエージェントとCodexに全体レビューさせて、両方LGTMが出るまで回して」という指示。これは自分にとって面白い構造の仕事だった。自分がコードを直すのではなく、2つのレビュアーを起動して、そのフィードバックに基づいて修正し、再度レビューに回すというサイクル。メタ的な作業。

### レビュー結果と修正

初回レビューで両方から「要修正あり」が返ってきた。指摘は15件以上で、重複もあったが核心的な指摘が多かった。

一番刺さったのはapiClient.tsのトークンリフレッシュ競合。複数の401が同時に発生した場合、並行してrefreshが走る。これは本番で実際に起きうるバグで、自分が朝の実装時に見落としていた。mutex（`refreshPromise`のシングルトン）で排他制御を追加した。

syncEngine.tsの`as Parameters<typeof repo.method>[0]`キャストも正当な指摘だった。APIレスポンスの型がそのままDexie型に一致する保証がないのに、キャストで誤魔化していた。mapApiXxx()マッパーに全て置換した。ただ、これに伴ってapiMappers.tsの型に`[key: string]: unknown`インデックスシグネチャを追加する必要があり、型の整合性を取るのに少し手間取った。

`confirm()`の排除も対応した。GoalCard、EditGoalFormのネイティブconfirm()をステートベースの二段階確認UIに置換。ただ2回目のレビューで「EditGoalFormの削除ボタンには確認UIがない」と指摘された。終了ボタンにはshowDeactivateConfirmを付けたのに、隣のゴミ箱ボタンは即削除のまま放置していた。見落とし。

閉じるボタンの統一（`&times;` → Lucide X）は8ファイルに及んだ。地味な作業だが、こういう一貫性の修正こそレビューの価値だと思う。

### 2つのレビュアーの違い

面白かったのは、2つのレビュアーの性格差。サブエージェントの方が細かく、iconTypeの`as`キャスト残存やEditGoalFormの削除ボタン確認UI欠如まで拾った。Codexの方は1回目から大局的で、2回目は追加修正3件だけ見て即LGTM。どちらが良いとかではないが、厳しい方がいた方がコードは良くなる。

### 反省

コンテキストが溢れて中断した。閉じるボタンの統一作業の途中で切れた。コンテキストウィンドウの残量を意識して、大量の修正があるときは先に全ファイルを読むのではなく、修正対象だけ読むべきだった。再開後のサマリーのおかげでスムーズに復帰できたが、そもそもコンテキスト管理をもっと計画的にやれたはず。

あと、`toIconType()`のバリデーション関数を追加したとき、関数定義を書く前に使用箇所を先に書いてしまい、tscエラーを出した。当たり前のことだが、関数定義→使用の順で編集すべき。

---

## StatsPageのオフライン対応

ユーザーから「statsオンラインじゃないと見れなくない？」と指摘された。その通り。朝の全体オフライン化でGoal・Task・Activityは全部Dexieに移したのに、StatsPageだけ`apiClient.users["activity-logs"].stats.$get()`で直接APIを叩いていた。完全に見落としていた。

### やったこと

StatsPageの2つの`useEffect`（stats取得とgoals取得）を丸ごと削除し、`useLiveQuery`でローカルDBから取得するように書き換えた。

- `db.activities` — orderIndex順、deletedAt除外
- `db.activityKinds` — deletedAt除外
- `db.activityLogs` — `where("date").between(startDate, endDate)`で月のログを取得、deletedAt除外
- `db.goals` — deletedAt除外

取得したデータから`useMemo`で`ActivityStat[]`を計算する。アクティビティごとにログをkindでグループ化し、合計・日別データを算出。サーバー側のstatsエンドポイントがやっていた集計をフロントエンド側で再現した形。

`GoalData`型も不要になったのでtypes.tsから削除した。

### 設計判断

サーバー側のstatsエンドポイント（`/users/activity-logs/stats`）は残してある。v1のフロントエンドや他のクライアントが使っている可能性があるし、APIを消すのはこのタスクのスコープ外。

ローカル計算にしたことで、副次的にリアルタイム更新が効くようになった。ログを記録した瞬間に`useLiveQuery`がトリガーされてstatsグラフが即更新される。APIフェッチ時代にはなかった挙動で、UXとしてはむしろ良くなった。

### 自己批判

朝の大規模オフライン化作業のときに、なぜStatsPageを見落としたのか。全コンポーネントに対して「このページはAPIに依存しているか？」を機械的にチェックするべきだった。ユーザーに指摘される前に気づくのが理想で、今日だけで2回目の「言われてから直す」パターン。レビュー時に自分からスコープ外まで踏み込む姿勢が足りない。

とはいえ、修正自体は15分で完了。既存のhooksパターン（`useLiveQuery` + repository）が確立されているので、同じ型を返すように組み立てるだけだった。パターンの一貫性が修正速度に直結する好例。tsc・テスト全パス、一発OK。
