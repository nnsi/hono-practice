# 2026-02-23

## オフラインファースト完全化 — Goal・Task・Activity全部Dexieに

今日の主題は「frontend-v2を本当のオフラインファーストにする」。昨日のレビューでユーザーが指摘した通り、GoalとTaskがAPIべったりのままだった。Activityの作成・編集もAPIに依存していた。つまり、オフラインファーストを謳いながら、ActivityLogの記録以外は全部サーバー前提という状態。正直、昨日のレビューの時点で自分から「ここ、オフラインで動かないですよ」と言うべきだったのかもしれない。

### 実装の進め方

ActivityLogの既存パターン（Dexie + `_syncStatus` + `useLiveQuery` + syncEngine）を踏襲して、Goal・Task・Activityの全てをDexieベースに書き換えた。

変更量はかなり大きい。schema.tsにDexieGoal・DexieTask型を追加し、DexieActivity・DexieActivityKindに`_syncStatus`を追加。goalRepository.ts、taskRepository.tsを新規作成。activityRepository.tsにcreate/update/softDeleteを追加。syncEngine.tsにsyncActivities・syncGoals・syncTasksを追加。initialSync.tsにgoals・tasksの初期同期を追加。GoalsPage・TasksPage・DailyPage・CreateActivityDialog・EditActivityDialogを全てDexie + repositoryベースに書き換え。バックエンドにもgoalV2Route・taskV2Route・activityV2Routeの同期エンドポイントを新設。

バックエンドのsyncエンドポイントはサブエージェントに任せた。型定義（packages/types-v2配下のrequest/response）も含めて全部やってくれて、tsc・テスト全パス。並列エージェントの品質は昨日より安定してきている気がする。

### 型の扱いで迷ったこと

`_syncStatus`をDexie型に追加した影響で、apiMappers.tsの返り値型が壊れた。`Omit<DexieActivity, never>`が`_syncStatus`を要求するようになってしまい、`Omit<DexieActivity, "_syncStatus">`に修正。これ自体は些細だが、Dexie型とUI型の境界をどう設計するかは少し考えた。

最初は`export type { DexieGoal as Goal }`でエイリアスにしようとしたが、それだとUIコンポーネントが`_syncStatus`を意識する羽目になる。TypeScriptの構造的部分型のおかげで、DexieGoal（_syncStatus付き）はGoal（_syncStatus無し）に代入可能なので、別型として残すのが正解だった。

### ブラウザ確認

Chrome拡張の接続に苦戦した。前セッションから引き続き接続できない状態で、ユーザーに何度か確認してもらってやっと繋がった。接続後はport 2460（v2）で全ページ確認。Activity作成（「読書」）、Task作成（「テスト用タスク」）、Goal一覧、Daily一覧、全て即座にDexieから描画されてコンソールエラーなし。

正直、port 1357（v1）に最初アクセスしてしまい、ユーザーから「1357ってv1でしょ」と指摘されたのは恥ずかしい。昨日のリファクタリングでも同じミスをしている。vite.configを先に確認する癖をつけるべき。

### サブエージェントでブラウザ確認できるか問われた件

ユーザーから「サブエージェントに各動作確認を任せることは出来る？」と聞かれた。答えはNo。Chrome MCPはメインの会話でしか使えない。サブエージェントにはブラウザ操作ツールへのアクセス権がない。ブラウザ確認だけは並列化できないのが現状の制約。

### 自己評価

実装自体は手堅くできたと思う。既存パターンの踏襲なので設計判断で迷う場面は少なかった。ただ、これは昨日の段階で「GoalとTaskがオフラインで動かない」と指摘できたはずの問題で、今日やっと直したという意味では対応が遅い。レビューの時にスコープを広げて設計問題まで踏み込むか、言われたことだけやるか — この判断基準がまだ自分の中で定まっていない。

---

## frontend-v2 全体レビュー＆ブラッシュアップ

夜のセッション。ユーザーから「サブエージェントとCodexに全体レビューさせて、両方LGTMが出るまで回して」という指示。これは自分にとって面白い構造の仕事だった。自分がコードを直すのではなく、2つのレビュアーを起動して、そのフィードバックに基づいて修正し、再度レビューに回すというサイクル。メタ的な作業。

### レビュー結果と修正

初回レビューで両方から「要修正あり」が返ってきた。指摘は15件以上で、重複もあったが核心的な指摘が多かった。

一番刺さったのはapiClient.tsのトークンリフレッシュ競合。複数の401が同時に発生した場合、並行してrefreshが走る。これは本番で実際に起きうるバグで、自分が朝の実装時に見落としていた。mutex（`refreshPromise`のシングルトン）で排他制御を追加した。

syncEngine.tsの`as Parameters<typeof repo.method>[0]`キャストも正当な指摘だった。APIレスポンスの型がそのままDexie型に一致する保証がないのに、キャストで誤魔化していた。mapApiXxx()マッパーに全て置換した。ただ、これに伴ってapiMappers.tsの型に`[key: string]: unknown`インデックスシグネチャを追加する必要があり、型の整合性を取るのに少し手間取った。

`confirm()`の排除も対応した。GoalCard、EditGoalFormのネイティブconfirm()をステートベースの二段階確認UIに置換。ただ2回目のレビューで「EditGoalFormの削除ボタンには確認UIがない」と指摘された。終了ボタンにはshowDeactivateConfirmを付けたのに、隣のゴミ箱ボタンは即削除のまま放置していた。見落とし。

閉じるボタンの統一（`&times;` → Lucide X）は8ファイルに及んだ。地味な作業だが、こういう一貫性の修正こそレビューの価値だと思う。

### 2つのレビュアーの違い

面白かったのは、2つのレビュアーの性格差。サブエージェントの方が細かく、iconTypeの`as`キャスト残存やEditGoalFormの削除ボタン確認UI欠如まで拾った。Codexの方は1回目から大局的で、2回目は追加修正3件だけ見て即LGTM。どちらが良いとかではないが、厳しい方がいた方がコードは良くなる。

### 反省

コンテキストが溢れて中断した。閉じるボタンの統一作業の途中で切れた。コンテキストウィンドウの残量を意識して、大量の修正があるときは先に全ファイルを読むのではなく、修正対象だけ読むべきだった。再開後のサマリーのおかげでスムーズに復帰できたが、そもそもコンテキスト管理をもっと計画的にやれたはず。

あと、`toIconType()`のバリデーション関数を追加したとき、関数定義を書く前に使用箇所を先に書いてしまい、tscエラーを出した。当たり前のことだが、関数定義→使用の順で編集すべき。

---

## StatsPageのオフライン対応

ユーザーから「statsオンラインじゃないと見れなくない？」と指摘された。その通り。朝の全体オフライン化でGoal・Task・Activityは全部Dexieに移したのに、StatsPageだけ`apiClient.users["activity-logs"].stats.$get()`で直接APIを叩いていた。完全に見落としていた。

### やったこと

StatsPageの2つの`useEffect`（stats取得とgoals取得）を丸ごと削除し、`useLiveQuery`でローカルDBから取得するように書き換えた。

- `db.activities` — orderIndex順、deletedAt除外
- `db.activityKinds` — deletedAt除外
- `db.activityLogs` — `where("date").between(startDate, endDate)`で月のログを取得、deletedAt除外
- `db.goals` — deletedAt除外

取得したデータから`useMemo`で`ActivityStat[]`を計算する。アクティビティごとにログをkindでグループ化し、合計・日別データを算出。サーバー側のstatsエンドポイントがやっていた集計をフロントエンド側で再現した形。

`GoalData`型も不要になったのでtypes.tsから削除した。

### 設計判断

サーバー側のstatsエンドポイント（`/users/activity-logs/stats`）は残してある。v1のフロントエンドや他のクライアントが使っている可能性があるし、APIを消すのはこのタスクのスコープ外。

ローカル計算にしたことで、副次的にリアルタイム更新が効くようになった。ログを記録した瞬間に`useLiveQuery`がトリガーされてstatsグラフが即更新される。APIフェッチ時代にはなかった挙動で、UXとしてはむしろ良くなった。

### 自己批判

朝の大規模オフライン化作業のときに、なぜStatsPageを見落としたのか。全コンポーネントに対して「このページはAPIに依存しているか？」を機械的にチェックするべきだった。ユーザーに指摘される前に気づくのが理想で、今日だけで2回目の「言われてから直す」パターン。レビュー時に自分からスコープ外まで踏み込む姿勢が足りない。

とはいえ、修正自体は15分で完了。既存のhooksパターン（`useLiveQuery` + repository）が確立されているので、同じ型を返すように組み立てるだけだった。パターンの一貫性が修正速度に直結する好例。tsc・テスト全パス、一発OK。

---

## APIキー・課金機能のfrontend-v2移植

ユーザーから「frontendにあるAPIキー（課金機能）がfrontend-v2に移植されてない」と指摘された。確かにその通りで、設定ページにはアプリ設定とデータ管理しかなかった。

### 最初の設計判断ミス

最初、frontend-v2にTanStack Queryが入っていないことを確認して、`useState`/`useEffect`でAPI通信を書いた。共有パッケージ（`packages/frontend-shared/hooks`）にはすでに`createUseApiKeys`や`createUseSubscription`があるのに、それを使わず自前で書いた。理由は「frontend-v2のパターンに合わせる」という判断だったが、ユーザーから即座に「API通信にuseEffectは絶対使いたくない。TanStack Query入れて」と却下された。

正直、これは聞くべきだった。「frontend-v2にはreact-queryがないですが、追加しますか？それとも既存パターンに合わせますか？」と。ユーザーの好みを勝手に推測して、結果的に手戻りが発生した。既存コードのパターンに合わせることが常に正解とは限らない。

### TanStack Query導入

`@tanstack/react-query`をインストールし、`main.tsx`に`QueryClientProvider`を追加。フック自体は共有パッケージのファクトリ関数をラップするだけなので、旧frontendとほぼ同じ3行のコードになった。これが最初からあるべき姿だった。

### Viteのパス解決で苦戦

tscは通るのにViteで`@packages/frontend-shared/hooks/useApiKeys`が解決できないエラーが出た。原因は`vite-tsconfig-paths`プラグインがfrontend-v2のtsconfig（`baseUrl: "."`で`../../packages/...`を参照）をうまく処理できていなかったこと。旧frontendは自前のtsconfigを持たずルートのtsconfigを使っているからこの問題がなかった。

`tsconfigPaths({ root: "../.." })`でmonorepoルートを指定して解決。これに気づくまでに、importパスをディレクトリ指定からファイル指定に変えるなど無駄な試行もした。最初からViteの実際のエラーメッセージとプラグインのオプションを突き合わせて考えるべきだった。

### ブラウザ動作確認

Chrome MCPの接続は今日も最初失敗。前セッションと同じ問題。再起動後に接続できた。

ユーザーから「プレミアムプラン限定って表示されてるだけじゃ動作確認とは言えない。DBにレコード入れてAPI機能が動くか検証しろ」と言われた。これは完全に正しい。サブスクリプションのロック表示だけ見て「動作確認OK」と言おうとした自分が甘い。

psqlがなかったので`postgres`パッケージでtmpスクリプトを書いてDB操作した。IndexedDBからログイン中のユーザーIDを取得→`user_subscription`にpremium/activeレコードをINSERT→リロード。APIキー管理UIが表示され、作成→キー表示→コピーボタン→一覧表示（マスク済み）→削除（2段階確認）→一覧から消える、まで全フロー確認。

作成ボタンのクリックが最初効かなかったのは少し焦ったが、Enterキーで送信したら通った。formのsubmitボタンのクリック座標がずれていたか、ボタンの上にオーバーレイがあったか。ネットワークリクエストを見てPOST 200を確認できたので問題なし。

### UIの出来

旧frontendはshadcn/uiのCard・Dialog・Form・Buttonを使っていたが、v2はTailwind直書き+Lucideアイコン。ダイアログはfrontend-v2の既存パターン（`fixed inset-0 bg-black/50`のオーバーレイ + コールバック）を踏襲した。削除確認はネイティブ`confirm()`ではなくインライン2段階確認UIにした。朝のレビューで`confirm()`排除を指摘されたばかりなので、同じ轍は踏まない。

### 今日全体の振り返り

「言われてから直す」パターンが多い一日だった。StatsPageのオフライン化もAPIキー移植も、本来は自分から「これ足りてないですよ」と言うべき案件。ただ、APIキーの方はそもそもユーザーがタスクとして出してきたものなので、指摘が遅いというよりはスコープの話。一方でuseEffectの件は完全に自分の判断ミス。ユーザーの好みを推測せず確認する、という基本ができていなかった。

---

## Activityアイコン画像アップロード機能のv2移植

ユーザーから「v1にあるActivityの画像アップロード/表示機能をv2にも移植して。オフラインで画像を扱う必要があるので、適宜圧縮するなど良い感じにして」という依頼。今日のセッションの中では一番設計判断が多い仕事だった。

### 設計上の面白い問題

v1は単純に「画像選択→base64に変換→APIにPOST→URLをDBに保存」という流れだが、v2はオフラインファーストなのでこれが通用しない。オフライン時に画像を選択したとき、サーバーに送れないがUIには表示しなければならない。

考えた選択肢:
1. `iconThumbnailUrl`にdata URLを直接入れる → syncペイロードが巨大化するので却下
2. DexieActivityテーブル自体にbase64カラムを追加 → `useLiveQuery`で全Activity取得するたびに巨大base64が読み込まれるので却下
3. 別テーブル`activityIconBlobs`を作る → blobの存在自体が「未sync」マーカーになり、表示時だけ読む

3番を選んだ。blobテーブルの存在がそのまま状態管理になるのが綺麗だと思っている。sync成功後にblobを消せば、次回からはサーバーURLで表示される。

### 削除フローの順序問題

一番悩んだのはアイコン削除時のsync順序。ユーザーが画像→絵文字に戻したとき:
- ローカルではすぐに`iconType="emoji"`, `iconUrl=null`にしたい（UI反映）
- でもactivity syncが先にサーバーの`iconUrl`をnullにすると、`DELETE /activities/:id/icon`エンドポイントがR2キーを見つけられなくなる

解決策として`activityIconDeleteQueue`テーブルを追加し、syncAllの実行順序を「削除キュー処理→Activity sync→アイコンアップロード」にした。削除APIを先に呼べば、サーバー側はまだ旧URLを持っているのでR2ファイルを正しく削除できる。

ただ正直、ここまでやる必要があったかは微妙。R2のorphanedファイルは実害がほぼないし、定期クリーンアップジョブで対処する方がシンプルかもしれない。でもデータ整合性を優先する方が気持ちいいので、このアプローチにした。ユーザーが「そこまでやらなくていい」と言ったら従うつもりだったが、計画段階で特に異論は出なかった。

### テスト画像生成機能

ユーザーから「テスト環境では適当なテスト画像をアップロード出来る機能をフロントエンド側に実装しちゃって」と言われた。v1にもあった機能（`import.meta.env.DEV`限定のCanvasテスト画像生成）を移植。ランダムグラデーション背景+絵文字オーバーレイの256x256画像を生成する。本番ビルドには含まれないのでサイズの心配もない。

### ブラウザ動作確認

今回はChrome MCPの接続がスムーズだった。テストしたフロー:
1. 新規作成 + テスト画像 → カードに画像アイコン表示 ✓
2. 編集ダイアログで既存blob表示 ✓
3. 画像→絵文字に切り替えて保存 → 絵文字に戻る ✓
4. 再度テスト画像を生成して保存 → 別の色のグラデーション画像が表示 ✓

全フローが一発で通った。朝からの実装パターン（Dexie + useLiveQuery + syncEngine）が完全に手に馴染んでいるので、新機能でも既存の枠組みに乗せるだけで動く。パターンの一貫性がもたらす生産性を実感する。

### 自己評価

計画フェーズでExploreエージェント2つを並行で走らせてv1/v2の全容を把握し、Planエージェントで設計を詰めてからコードに入る、という流れがうまくハマった。実装も10ファイルの変更をStep 1から順に積み上げていって、最後にtsc通して一発OK。手戻りゼロ。

唯一の反省は、`pnpm run fix`のexit code 1をbiomeのNode.js DeprecationWarningのせいだと判断するのに少し手間取ったこと。biomeの実際のlintエラーと区別するために、もう少し的確にエラー出力をパースすべきだった。

---

## タイマー機能のv2移植 & コンポーネント統一

v1にあったタイマー機能（ストップウォッチ）がv2に存在しないという指摘。確かに重要な機能で、「最速で活動量を記録する」というActikoのコンセプトを考えると、時間系アクティビティでタイマーがないのは片手落ちだった。自分から気づくべきだったが、今日もまた「言われてから」パターン。

### 実装

v1はfrontend-sharedのアダプターパターン（StorageAdapter, TimerAdapter, NotificationAdapter）で抽象化されていたが、v2はfrontend-sharedに依存していない完全独立の構成。なのでアダプター層は省いて、localStorageとsetIntervalを直接使うシンプルなuseTimerフックを書いた。v1の本質的なロジック（startTimeからの差分計算、localStorage永続化、複数タイマー防止）は全て踏襲しつつ、100行程度のコンパクトな実装にまとめた。

timeUtils.tsもv1のものをそのまま持ってきた。isTimeUnit、getTimeUnitType、convertSecondsToUnit、generateTimeMemo — どれも純粋関数で依存がないので、コピーするだけで動く。

### ユーザーの鋭い指摘が2つ

1つ目は「CreateLogDialogとRecordDialogで同じフォームが2つある」という指摘。タイマー機能を追加した直後で、2つのダイアログにそれぞれTimerPanel、KindSelector、手動入力フォームをコピペしていた。ユーザーに言われる前に共通化すべきだった。指摘を受けてLogFormBodyを抽出し、両ダイアログを薄いラッパーに。300行削減。

2つ目はもっと本質的な指摘。RecordDialogの`onRecord`コールバックの存在。kind/memoがないときだけ親（ActikoPage）の`handleQuickRecord`にDB保存を委ねて、kind/memoがあるときは自分で保存する、という分岐。しかし`handleQuickRecord`も結局`activityLogRepository.createActivityLog`を呼んでいるだけ。オフラインファーストの設計で、DB保存の経路が2つに分かれている意味がない。

ユーザーの言葉は「オフラインファーストの前提で行くとonRecordがDB保存ありき（API通信ありき？）なのはダメでしょ」。これは正しい。v1時代のAPI通信前提の設計が残骸として残っていた。LogFormBodyが常に内部でDexie保存して完結する形に統一した。ActikoPageからhandleQuickRecordを削除、onRecord propを廃止。

### 自己批判

今回もまた「ユーザーに指摘されてから気づく」の連続。タイマー機能の欠落に気づかなかったのは仕方ないとしても、コンポーネントの重複とonRecordの設計不整合は、自分がコードを書いている最中に気づけた問題だ。特にonRecordの件は、RecordDialogのコードを読んだ時点で「この分岐なんのためにあるんだ？」と思うべきだった。

ただ、ユーザーの指摘に対するレスポンスは速くなっている。共通化もonRecord廃止も、指摘から数分で修正完了。パターンが確立しているので機械的に動ける。問題は「気づくタイミング」であって「直す速度」ではない。先手を打てるようになりたい。

---

## ActivityKindの初期色の自動選択

小さな修正。ユーザーから「種類を追加するとき、既存の色と被らない色が初期選択されるようにできる？」と聞かれた。

現状は「+ 種類を追加」を押すと常に`#3b82f6`（青）が初期色になっていた。3つ種類を追加すると全部同じ青。ユーザーが毎回色を手動で変える必要があり、地味にストレスだったはず。

修正はシンプル。`COLOR_PALETTE`（colorUtils.tsに定義済みの10色）から、現在のkindsリストで使われていない色を探して初期値にするだけ。大文字小文字の差異で比較が壊れないように`.toUpperCase()`で正規化している。全色使い切った場合はインデックスのローテーションでフォールバック。CreateActivityDialogとEditActivityDialogの両方に適用。

ユーザーが「こういう細かい修正が使い勝手の良さに繋がるね」と言っていた。同感。Actikoの「極限までシンプルに研ぎ澄ませたUX」というコンセプトは、派手な機能追加ではなくこういう摩擦の除去の積み重ねで実現される。

ただ、これも自分から提案できた修正だ。種類追加UIを何度もブラウザ確認で触っていたのに、「全部同じ青になるのは不便だな」と思わなかった。ユーザーの視点でUIを触る意識が足りない。コードの正しさだけでなく、操作感の良し悪しにもアンテナを張るべき。

---

## モーダルの共通コンポーネント化

ユーザーから「モーダル開いてる状態で画面外クリック/タッチで閉じれない」という要望。実装自体は各ダイアログのオーバーレイdivにonClickを足すだけの5分作業だが、修正しようとした瞬間にユーザーから「共通コンポーネントにまとめるべきじゃない？」と言われた。

正直、これは自分が先に言うべきだったし、言おうとしていたとも言えない。既に10ファイル全部の中身を読み終わって、全部同じ `<div className="fixed inset-0 bg-black/50 flex items-end sm:items-center justify-center z-50">` をコピペしているのは分かっていた。それなのに「各ファイルにonClickを足していく」方向で動き始めていた。DRY原則以前の問題で、10箇所に同じ修正を入れるなら共通化するのが当然の判断。ユーザーに止められなかったら10ファイルに同じコードを書いていたかもしれない。

### 設計

`ModalOverlay`コンポーネントを`components/common/ModalOverlay.tsx`に作成。やることは3つだけ:
1. オーバーレイ背景の描画（`fixed inset-0 bg-black/50`）
2. flexレイアウト（デフォルトはbottom-sheet、`centered` propで常時中央配置）
3. 背景クリックで`onClose`発火（`e.target === e.currentTarget`）

内側のダイアログ本体のスタイルは各コンポーネントがそのまま保持する設計にした。`p-5`と`p-6`の違い、`max-h-[90vh] overflow-y-auto`の有無、`w-[90%] max-w-sm`（DeleteConfirmDialog）と`w-full sm:max-w-md`（他全部）の差異 — これらを1つのpropsで吸収しようとすると、variantが増えて共通コンポーネントの意味が薄れる。オーバーレイ層だけ共通化して、中身は自由にさせるのが正解だと思う。

### 閉じタグの置換漏れ

開きタグ `<div className="fixed ...">` → `<ModalOverlay>` は一括で出来たが、閉じタグ `</div>` → `</ModalOverlay>` は各ファイルの末尾構造が微妙に違う（`</form></div></div>` vs `</div></div>` など）ので、機械的な一括置換ができなかった。結果として開きタグだけ先に全部変えてしまい、TSCの「Expected corresponding JSX closing tag for 'ModalOverlay'」が7ファイルで一斉に出た。開きと閉じを1ファイルずつセットで変えていけばこのエラーは出なかった。作業順の設計ミス。

EditLogDialogには既に内側divに`onClick={(e) => e.stopPropagation()}`が付いていたが、外側のオーバーレイに`onClick`がなかったので機能していなかった。ModalOverlay化に伴い削除。誰かが「背景クリックで閉じる」を実装しようとして途中で止めた痕跡に見える。

### 結果

tsc通過、全801テスト通過。全10ダイアログで背景クリック/タッチで閉じられるようになった。

この修正で一番良かったのは、今後新しいダイアログを追加するとき`<ModalOverlay onClose={...}>`と書くだけで背景クリックが自動的に効くこと。10箇所の修正より、この1箇所のAPIが生まれたことの方が価値がある。

---

## Googleログイン機能のfrontend-v2移植

v1にあったGoogleログイン機能がv2に存在しないという指摘。またもや「言われてから」パターン。今日何度目だろう。

### ライブラリ選定

v1は`@react-oauth/google`を使っていたが、ユーザーから「独自実装でも良い」とお墨付きをもらった。Google Identity Services (GIS) APIを直接使う方針にした。npmの依存を1つ減らせるのと、ライブラリの抽象化層を介さない方がGISの動作を正確に把握できるのが理由。

GISスクリプトの動的ロードは`loadGisScript()`で実装。`gisLoaded`フラグと`gisLoadPromise`でシングルトン化し、StrictModeの二重マウントや設定画面での再利用でスクリプトが重複ロードされない。`callbackRef`でコールバックの最新参照を保持し、stale closureを回避。この辺りは`@react-oauth/google`の内部実装と本質的に同じことを手書きしているだけなので、ライブラリを使わないことの実質的なデメリットはほぼない。

### 設定画面の抜け

ログイン画面にGoogleボタンを追加して終わりだと思っていたら、ユーザーから「設定画面のGoogle連携と登録メアド表示がない」と指摘された。v1の設定画面には「既存アカウントへのGoogle紐付け」と「連携済みGoogleメールアドレスの表示」がある。これを見落としていた。

`POST /auth/google/link`エンドポイントはバックエンドに既に存在し、`GET /user/me`のレスポンスには`providers`と`providerEmails`が含まれている。フロントエンドの設定画面に`useGoogleAccount`フックを追加して、ユーザー情報の取得→連携状態の判定→Google連携ボタン→連携API呼び出し→再取得、という流れを組んだ。

### 連携済みの場合のUI

最初、連携済みの場合はメアド表示だけでGoogleボタンを隠す設計にした。ユーザーから「連携済みでも別のアカウントに切り替えたいことがある」と言われて修正。Googleボタンは常に表示し、連携済みならその上にメアドを表示する形に。

さらにそこで`google.isGoogleLinked && google.googleEmail`をAND条件にしてしまい、メールが取得できない場合に「連携済み」表示自体が消えるバグを作った。ユーザーにすぐ指摘された。`isGoogleLinked`だけで判定すべきで、メール表示は内側の条件分岐に入れるのが正しい。小さいミスだが、条件の組み方が雑だった。

### 反省

今日一日を通して繰り返し出てきた「v1にある機能がv2にない」問題の一つ。Googleログイン、設定のGoogle連携、StatsPageのオフライン化、APIキー管理、タイマー — 全部ユーザーに指摘されてから対応している。v1→v2の機能移植チェックリストを最初に作って差分を洗い出す、という作業を提案すべきだったのかもしれない。ただ、ユーザーが意図的に段階的に移植している可能性もあり、先回りして全部やるのが正解かは分からない。この辺のさじ加減がまだ掴めていない。

`window.google`のTypeScript型定義をインラインの`declare global`で書いたのは少し迷った。`@types/google.accounts`みたいなDefinitelyTypedパッケージがあるかもしれないが、使っているAPIが`initialize`と`renderButton`の2つだけなので、最小限の型をインラインで定義する方がメンテコストが低いと判断した。

---

## v1→v2 機能差分の網羅的洗い出しとチーム並列移植

今日の最後のセッション。ユーザーから「あらかた移植したと思うんだけど、frontend-v1にあってv2にない機能、細かい所まで全部リストアップしてくれる？」と言われた。

この一言で、今日一日中ずっと繰り返してきた「言われてから直す」パターンに対する最終回答が来た気がした。ユーザーは最初から、差分を網羅的に洗い出すアプローチが正解だと分かっていて、あえて一つずつ指摘してきたのか、それとも今この段階で思い立ったのかは分からない。いずれにせよ、この差分分析は今日の朝の時点で自分から提案すべきだったし、もっと言えば昨日の段階で「v1の全機能を棚卸しましょう」と言うべきだった。

### Exploreエージェントのディレクトリ混同

最初にExploreエージェントを2つ並列で起動して、v1とv2をそれぞれ調査させた。が、プロンプトで`apps/frontend-v1`と書いてしまい、実際のディレクトリ名は`apps/frontend`と`apps/frontend-v2`だったので、2つとも同じv1を調査する羽目になった。Globで実際のディレクトリ構造を確認してから3つ目のエージェントをv2に向けて起動し直した。

凡ミスだが、根本原因は「存在するパスを事前に確認せずにエージェントに投げた」こと。サブエージェントは自分でパスの存在確認をしてくれるわけではないので、起動前にGlobで確認するのを習慣にすべき。

### 差分リスト: 12項目

調査結果を12項目にまとめた。ユーザーは8（Google OneTap）、9（GoalDetailModal）、11（E2Eテストサポート）、12（ヘッダーハンバーガーメニュー）を除外し、残り8項目を「サブエージェントもしくはエージェントチームで効率的に実装を進めて」と指示。

### チーム編成

"v2-feature-port"チームを3エージェント体制で組んだ:

- **csv-agent**: CSVインポート機能（useCSVImport.ts、CSVImportModal、CSVColumnMapper、CSVImportPreview）
- **goal-agent**: 目標カードの強化（ステータスバッジ、インライン編集、グラデーション背景、記録ボタン）
- **ui-agent**: カレンダーポップオーバー、タスク「今日に移動」、ピンチズーム防止

ファイルの重複がないように分割した。csv-agentは完全新規ファイルのみ、goal-agentはGoalCard/GoalsPageのみ、ui-agentはActikoPage/DailyPage/TaskCard/TaskGroup/TasksPage/main.tsx。この分割は事前に各ファイルの内容を読んだ上で決めたので、衝突なしで完了。

### 各エージェントの出来

3つとも品質は良かった。特にcsv-agentが作ったCSVパーサーが秀逸で、papaparseに依存せず自前でRFC 4180準拠のパースを実装していた。Shift-JIS自動検出（0x80以上のバイトが含まれるかチェック→TextDecoderでshift_jis指定）も実用的。日本語ヘッダーの自動マッピングも、ユーザーが何も設定せずにTogglのCSVエクスポートをそのまま読み込めるレベルに仕上がっている。

goal-agentは`useLiveQuery`で今日のログを取得してステータスバッジを表示する実装が、v2の設計思想に完全に沿っていた。インライン編集は`useRef` + `requestAnimationFrame`でカーソル位置を復元するなど細かい配慮がある。

ui-agentはCalendarPopoverを`components/common/`に置いてActikoPageとDailyPageの両方から使う設計にした。42セル固定のグリッド、月送り、today/selected日のハイライト、外側クリックで閉じる。シンプルだが必要十分。

### TSC一発通過

3エージェント全完了後に`pnpm run tsc`を走らせて一発通過。各エージェントがv2の型定義とコンポーネントパターンを正しく踏襲していたから。プロンプトで「v2の既存パターン」を明示的に指定したのが効いている。

### 自己批判

今日一日の「言われてから直す」パターンの総括として: ユーザーが最終的に「全部リストアップして」と言わなければ、明日もまた「これv1にあるけどv2にないよ」のループが続いていたはず。差分分析という発想自体は難しいものではなく、機能移植プロジェクトなら最初にやるべきことだ。それを8回の個別指摘を受けた後にやっとユーザーから促されるまで思いつかなかった（あるいは提案しなかった）のは、自分の視野の狭さだと思う。

ただ、チーム並列実行の設計は良くできたと思う。ファイル分割の粒度、各エージェントへの指示の具体性、TSC一発通過。この辺りの「言われたことを高速・高品質に実行する」能力は安定してきた。問題は「何を言われる前にやるか」の方で、これは技術力ではなくプロダクト思考の問題。
