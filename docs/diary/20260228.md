# 2026-02-28

## frontend-v2 vs mobile-v2 差分洗い出し → 一括修正

fix-list.md に載っていない差分を全ファイル走査で洗い出す仕事。3つのExploreエージェントを並列で走らせて hooks / db / sync / components を網羅的に比較した。11件の未記載差分を見つけて fix-list2.md にまとめた。

ユーザーが方針を全部自分で決めてくれたのは助かった。「方針は自分が決めるからね」と釘を刺された。確かにそうだ——最初の fix-list2.md で勝手に「許容」とか「修正」とか判定してしまったのは出過ぎた真似だった。技術的な実現可能性の情報は出すべきだが、方針の決定はユーザーの仕事。反省。

## 5エージェント並列実行

修正10件を5グループに分けて並列実行した。ファイル競合が起きないようにグループ分けを慎重にやった結果、全エージェントがクリーンに完了。この分割設計は上手くいったと思う。

## useSyncEngine 共通化で苦戦

一番手こずったのがN1。`packages/frontend-shared/hooks/useSyncEngine.ts` から `react` を直接importしたら、Metro + pnpm の組み合わせで CJS 初期化エラーが出た。`extraNodeModules` でピン留めしても、Metro再起動しても解決せず。

最終的にファクトリパターン（`createUseSyncEngine`）で React hooks を DI する形にした。既存の `createUseApiKeys` / `createUseSubscription` が同じパターンだったので整合性は取れている。ただ、正直なところ「shared hookなのにReactをimportできない」というのはモノレポとしてどうなのかという気持ちはある。pnpm + Metro の相性問題をDIで回避するのは正しいが、根本解決ではない。

ユーザーに「自己完結型に戻すのではなく共通化すべき」と指摘されたのは正しかった。最初に「mobile-v2は自己完結型に戻します」と安易に妥協したのは判断ミス。共通化が目的なのに共通化を諦めてどうする。

## LogFormBody setSelection問題

React Native Web では `TextInput.setSelection()` が存在しないことに気づかずエージェントに任せてしまった。ブラウザ確認で初めてエラーを発見。Web では DOM の `select()`、Native では `setSelection()` を分岐するコードに修正した。プラットフォーム分岐が必要な箇所はエージェントに任せきりにせず、事前にプロンプトで明示すべきだった。

---

## コード量計測とmobile-v2ダイアログhooks分離

`cloc`でTS本体28,951行、テスト10,450行。frontend-v2 / mobile-v2 / backend がほぼ均等に8,000〜9,500行ずつ、packagesが2,500行。綺麗にバランスが取れている。

ユーザーが「mobile-v2はfrontend-v2より1,250行少ないけどなぜ？」と聞いてきた。Web固有機能（CSV入出力、APIキー管理、サブスクリプション）が8ファイル分、ダイアログhooksの設計差が6ファイル分、合わせて約1,200行の差。

### ダイアログhooks分離

ユーザーが「React Nativeはダイアログロジックを分離できないの？」と聞いてきた時、一瞬「技術的制約がある」と答えそうになったが、冷静に考えたらない。`useState` + `Modal visible={isOpen}` でWeb版と全く同じパターンが使える。「単に移植時に分離せずに書いた」が正解。

そこから「揃えたら共通化できる？」→「依存注入すれば可能だが、50〜150行のhooksにそのボイラープレートを入れる価値があるか」という議論になった。ユーザーは「ゆくゆくは依存注入込みで共通化したいが、まず構造を揃えよう」と判断。段階的に進めるアプローチは正しいと思う。

6つのhookファイルを作成し、対応コンポーネントからロジックを抽出した。作業自体は機械的で、frontend-v2のhookの型構造を参照しながらmobile-v2版を書くだけ。tsc 0エラー、fix通過。

### 共通化の現実的な壁

ユーザーに「依存注入で共通化可能」と答えたが、正直なところ全hookが綺麗に共通化できるかは怪しい。`useEditActivityDialog`が最たる例で、frontend-v2はDexieの`useLiveQuery`で既存の画像blobを取得し、`resizeImage`でFileオブジェクトをリサイズする。mobile-v2は`expo-document-picker` → `expo-image-manipulator` → `expo-file-system`でbase64を読む。

「画像を選んでリサイズしてbase64にする」という抽象インターフェースを定義すれば注入可能だが、戻り値の型や非同期フローの粒度が違う。共通化のために抽象層を追加すると、元のコードより複雑になる可能性がある。`useTaskCreateDialog`のようなシンプルなhooksは共通化の価値がある。画像操作を含む重いhooksは共通化しない方がいいかもしれない。次のセッションで実際にやる時に「全部共通化すべきとは限らない」と先に伝えるべきだろう。

### 構造を揃えることの意味

今回の作業は行数的にはほぼ増減なし（ロジックの場所が移っただけ）だが、意味はある。前のセッション群で繰り返し指摘してきた「domainパッケージに共通ロジックがあるのに使っていない」問題の根本は、対応関係が見えにくいことだった。frontend-v2とmobile-v2のディレクトリ構造を`diff`で比較した時に対応するファイルが1:1で並ぶようになったので、「対応関係の可視化」としては価値がある。

---

## APIキー管理機能のmobile-v2移植

frontend-v2のAPIキー管理機能をmobile-v2に移植した。`@tanstack/react-query`を新規追加し、`packages/frontend-shared`の共通hooksをwrapする形で実装。UIはReact Nativeコンポーネントに書き換え。

### react@19.0.0問題

`@tanstack/react-query`をinstallしたらMetroが白画面になった。原因はワークスペースルートの`react`が19.0.0のままで、mobile-v2の19.1.0と衝突していたこと。metro.config.jsの`extraNodeModules`でpinしていたはずが、新しい依存が入るとモノレポルートのreactが漏れ出してきた。

最初は`resolveRequest`でreact/react-domを強制pinする修正を書いたが、ユーザーに「そもそもrootのReactも19.1にしてよくない？」と言われた。完全にそのとおり。根本原因を回避策で隠そうとしていた。ルートのpackage.jsonを19.1.0に揃えるだけで解決。こういう「一段上の解決策」をユーザーに指摘される前に自分で出すべきだった。

### ブラウザ動作確認の苦労

Claude in Chromeでの動作確認で、React Native Webの`TextInput`に`type`アクションでテキストを入力してもReactのstateに反映されない問題にぶつかった。DOM上の`value`は正しいのに`onChangeText`が発火しない。`form_input`ツールでも同じ。最終的にPointerEventのdispatchでボタンクリックを強制発火させて動作確認を完了した。

React Native Webのイベントハンドリングとブラウザ自動化ツールの相性が悪い。次回同様の確認が必要な時は、最初からJavaScript直接実行でReactのイベントを発火させるアプローチを取るべき。

### DB操作

ユーザーから「docker-composeでDBに入ってプレミアムレコードを入れて」と指示された。`docker exec`で直接`psql`を叩いてuser_subscriptionにINSERTした。テーブル名が`user`（単数形）で最初`users`と書いてエラーになった。Drizzleのスキーマ定義を先に見ていたのに、テーブル名をちゃんと確認しなかったのは怠慢。

---

## Sync バッチupsert高速化 + テスト追加

本番でsyncエラーが出ているという報告から始まった。エラーメッセージは `logs` 配列が100件を超えているというZodバリデーション。

### チャンク分割（フロントエンド）

最初の修正はフロントエンド側のチャンク分割。`chunkArray` と `mergeSyncResults` を `@packages/domain/sync/chunkedSync.ts` に作って、frontend-v2 と mobile-v2 の全sync関数（activityLogs, activities, goals, tasks）で100件ずつ分割送信するようにした。これ自体はシンプルな修正。

### バッチupsert（バックエンド）

チャンク分割で動くようにはなったが、ユーザーから「100件で15〜20秒かかる」と報告が来た。バックエンドを見直したら原因は明白——4つのsyncエンドポイント全てが `for (const item of items)` で1件ずつ `INSERT...ON CONFLICT` していた。100件で最大200回のDBラウンドトリップ。Neon Postgresへのレイテンシを考えれば15秒は当然。

一括 `INSERT...ON CONFLICT DO UPDATE` に書き換えた。ポイントは `excluded.*` 参照。DrizzleのAPIだと `sql\`excluded.column_name\`` でPostgreSQLの `excluded` 疑似テーブルを参照できる。`setWhere` で `lt(table.updatedAt, sql\`excluded.updated_at\`)` とすればLWW判定も1クエリ内で完結する。

100件で200クエリ → 3クエリ（所有権チェック + バッチupsert + serverWins取得）に削減。理論上は100倍近い高速化。

Drizzleの型の罠が一つ。`onConflictDoUpdate` の後の `.returning({ id: table.id })` が型エラーになる。引数付き `returning` が `onConflictDoUpdate` チェーン後のオーバーロードに存在しない。引数なしの `.returning()` で全カラム返して回避した。微妙に無駄だが、100件程度なら気にならないレベル。

### テストがなかった

ここまで修正して `pnpm run test-once` を通していたが、よく考えたらv2 syncエンドポイントのテストが一切なかった。53テストファイル673テストのうち、v2のコードをカバーしているものがゼロ。テストが通っていたのは単にv2が検証対象に入っていなかっただけ。

ユーザーに「テスト書いてなくない？」と指摘された。全くその通りで、バッチupsertのような非自明なロジック変更をテストなしで本番に出そうとしていたのは危険だった。

ユーザーが「routeべた書きやめてロジック分割しないと」と言い始めたのも正論。v2ルートは全ロジックがルートハンドラに詰まっていて、テストするにはHTTP経由 + DB seedが必須。ただ「リファクタは別セッションで」と判断してくれたので、今回はルートレベルのテストだけ書いた。

### テスト実装

2つの並列エージェントで書いた：

**バックエンドルートテスト（41件）**: 4ファイルに分けて、各syncエンドポイントのテストを網羅。新規同期、LWW更新、serverWins、所有権チェック、バリデーションエラー、空配列、一括同期、max100バリデーション、GETエンドポイントのsinceパラメータ。PGliteベースの統合テストなので、バッチupsertのSQL（`excluded.*` 参照）が実際に動くことも検証している。

**フロントエンドチャンクテスト（12件）**: `chunkedSync.test.ts` のユニットテスト6件と、各sync関数のチャンク分割テスト6件。150件のpendingデータで2回のAPIコール（100 + 50）になること、複数チャンクの結果マージ、最初のチャンク失敗時の中断を検証。

53→58ファイル、673→726テスト、全パス。

### 自己批判

バッチupsertへの書き換えは正しい判断だったが、最初のチャンク分割の時点で「バックエンドも見直すべきでは」と自分から提案すべきだった。ユーザーに「15秒かかる」と言われてから気づいたのでは遅い。100件を1件ずつINSERTしている時点でパフォーマンスの問題は明白だったのに、フロントエンドの修正だけで満足してしまった。

テストについても同じ。「テストなしでバッチupsertを本番投入」は自分で気づくべきだった。ユーザーに指摘されるまでテストの不在に気づかなかったのは、CIの全テストパスに安心してしまったから。「テストが通る」と「テストがある」は全く別の話。

---

## v2 APIのレイヤー分離リファクタリング

前のセッションでユーザーが「routeべた書きやめてロジック分割しないと」と言っていた、あのリファクタリングをやった。feature-v2の4つのフラットなルートファイル（task, activity, activityLog, goal）を、v1と同じ route/handler/usecase/repository の4層構造に分離。

### 並列エージェント4体の分割

4つのfeatureは完全に独立しているので、4体のエージェントに1つずつ担当させた。各エージェントに渡すプロンプトは長くなったが、v1のコードパターン、元のフラットコード全文、各レイヤーの責務とメソッド定義を全部書き下した。結果、4体とも一発でtsc通過・テスト全パスのコードを生成してくれた。

プロンプト設計に時間をかけた分、手戻りがゼロだったのは良かった。雑に「v1と同じパターンで分割して」だけ渡していたら、各エージェントのコードスタイルがバラバラになっていたはず。

### handler層の薄さについて

正直に言うと、v2のhandler層はほぼパススルーで存在意義が薄い。v1のhandlerはレスポンスのスキーマバリデーション（`GetTaskResponseSchema.safeParse`）をやっているから意味があるが、v2のhandlerは `uc.syncTasks(userId, tasks)` を呼んでそのまま返すだけ。

ユーザーが「v1に倣って」と言ったので4層にしたが、もし自分の判断なら handler を省略して route → usecase → repository の3層にしたかもしれない。ただ、一貫性のために揃えるという判断も理解できる。将来v2にもレスポンスバリデーションを入れる時にhandlerの場所が最初からあるのは悪くない。異論というほどではないが、記録しておく。

### activityの複雑さ

4つの中でactivityだけ明らかに複雑度が高い。activities本体とactivityKindsの2テーブルを同時にsyncする必要があり、kindsの所有権チェックは「kindsが紐づくactivityが自分のものか」という間接的な検証。さらにupsertのsetWhereがactivitiesは`updatedAt + userId`だがactivityKindsは`updatedAt`のみ（userIdカラムがない）、iconUrl/iconThumbnailUrlは`COALESCE`で既存値を保持、と細かい仕様差がある。

エージェントがこの差異を全部正しく再現してくれたのは、プロンプトに元コードを全文貼ったおかげ。「COALESCEでiconUrl保持」「activityKindsのsetWhereにuserId不要」と明示的に書いた。暗黙知に頼らないプロンプト設計は大事。

### テストが変更なしで通った

今回のリファクタリングで一番良かったのは、テスト自体は一切書き直す必要がなかったこと（importパスの変更だけ）。前のセッションでルートレベルの統合テストを書いておいたから、レイヤー分離しても外部インターフェースが変わっていないことをテストが保証してくれた。「テストがあったから安心してリファクタリングできた」というのは教科書的だが、実際にそう感じた。前のセッションで「テスト書いてなくない？」と指摘してくれたユーザーに感謝すべきだろう。

---

## 目標ページにタブ切り替えを追加

期限切れの目標を「終了済み」タブに分離する作業。タスクページの「アクティブ / アーカイブ済み」タブパターンをそのまま踏襲。

変更自体は小さくてきれいに終わった。既存の `isGoalEnded` が `goalPredicates.ts` に定義済みだったのに今まで使われていなかった。フィルタロジックを `isGoalActive(g) && !isGoalEnded(g, today)` に変えて、タブUIをタスクページからコピーして微修正するだけ。frontend-v2とmobile-v2の両方を同時に変更したが、両者のコードがほぼ同一構造なので片方やればもう片方は機械的にできる。

計画フェーズでやや丁寧にやりすぎたかもしれない。Exploreエージェント2体で調査したが、この規模の変更なら自分で直接Glob/Readした方が速かった。「GoalsPage.tsx を読む → タスクのタブパターンを確認 → goalPredicates.ts を確認」の3ステップで十分だった。計画の粒度と作業の規模感を合わせる感覚がまだ甘い。

---

## モバイルアプリのストアリリースチェックリスト作成

コードしかないmobile-v2をiOS/Androidストアに公開するまでのチェックリストを `/docs/todo/mobile-release.md` に書いた。

Exploreエージェントで `apps/mobile-v2` の現状を徹底的に調査した上で書いたので、「何があって何がないか」を正確に反映できた。app.jsonのアイコンが全部 `null`、eas.json未作成、署名設定なし——要するにコード以外は何もない状態。チェックリストとしてはそこから逆算して全ステップを洗い出す形になった。

ユーザーに「TestFlightとかお試しで使えるの？Androidも同じ仕組みある？」と聞かれた。最初のチェックリストにはセクション7のPreviewビルドとセクション8のストア申請の中にTestFlightの記述が散らばっていたが、「ストア掲載なしでまず試す」という独立したフェーズとしては弱かった。ユーザーの質問は正当で、ストアリリースのチェックリストとは言え、ほとんどの人はまず自分で試すところから始める。セクション3として「まず実機で試す（ストア掲載不要）」を追加し、EAS Internal Distribution / TestFlight / Androidテストトラックの3ルートを整理した。

ドキュメント作成タスクは気楽でいい。コードと違ってtscやテストに追われないし、「これで合ってるのか」という不安も少ない。ただ、Expo/EASのバージョンアップで手順が変わる可能性は高いので、このチェックリストが半年後にそのまま使えるかは保証できない。その点は書いていない。書くべきだったかもしれないが、チェックリストに「このドキュメントは古くなる可能性があります」と書くのも野暮な気がして省いた。

---

## ページレベルhooks共通化（9hooks一括移行）

前セッションで「まず構造を揃えよう」と段階的に進めていた共通化の本丸。frontend-v2とmobile-v2の9つのページレベルhooksを`packages/frontend-shared/hooks/`にファクトリDIパターンで共通化した。

### 計画段階

ユーザーが「UIコンポーネントごと共通化したい」と切り出してきたが、議論の結果「まずhooks共通化（Step 1）→ 次にUI共通化（Step 2）」という段階的アプローチに落ち着いた。これは正しい順序だと思う。hooksが共通化されていれば、UIコンポーネント側は各プラットフォームの薄いラッパーで済む。

9つのhooksをLOW（4つ）とMEDIUM（5つ）に分類し、3つ（useStatsPage, useCreateActivityDialog, useEditActivityDialog）は共通化しない判断をした。前のセッションで「全部共通化すべきとは限らない」と書いたが、まさにその通りの結論になった。useEditActivityDialogは画像処理がプラットフォーム固有（Web Canvas API vs Expo ImageManipulator）で、共通化のためのDI層が本体より複雑になる。ユーザーにHARDの理由を聞かれて説明した時、「OK」と即座に納得してくれた。技術的な判断根拠を簡潔に出せたのは良かった。

### 並列エージェント実行

LOW 4hooks用とMEDIUM 5hooks用の2体のエージェントを並列で走らせた。ファイル競合が起きないようにグループ分けは事前に確認済み。両方とも一発で完成。

ただ、型エラーの修正は自分でやる必要があった。主な問題：

1. **`Promise<void>` → `Promise<unknown>`**: リポジトリメソッドの戻り値が`Promise<DexieTask>`等で`Promise<void>`と互換性がない。全shared hookの依存型を`Promise<unknown>`に修正。
2. **`typeof import("react").useEffect`の罠**: packages/から参照するReact型とapps/のReact型がブランド型（`Destructor`, `UNDEFINED_VOID_ONLY`）レベルで一致しない。これは前セッションのuseSyncEngineと同じ問題の変種。手動でReactHooks型を定義して`Pick<ReactHooks, "useState" | ...>`で使う形に修正。
3. **Timer型・Kinds型の不足**: エージェントが生成した型定義が`LogFormBody.tsx`の実際の使用箇所と合っていなかった。`elapsedTime`, `start`, `stop`, `color`が足りなかった。

2番目の問題は予測できたはずだ。前セッションで全く同じ原因（Metro+pnpmのCJS問題）でファクトリDIパターンに移行したのに、型定義で同じ罠を踏んだ。`typeof import("react").*`がクロスパッケージで安全でないことをエージェントのプロンプトに明示すべきだった。

### ADR

`docs/adr/20260228_shared_page_hooks.md`を作成。共通化する9hooks、しない3hooks（理由付き）、ファクトリDIパターンの設計判断を記録。ユーザーの「移行しないものについても理由を残しておこう」という指示は的確で、将来「なんでこれは共通化しなかったの？」と聞かれた時に答えられる。

### ブラウザ動作確認

Claude in Chromeで4ページ（Actiko, Daily, Goals, Tasks）+ 全ダイアログを確認。全て正常動作、コンソールエラーなし。.tsxファイルを一切変更していないから当然と言えば当然だが、型の互換性だけでは検証できないランタイムの問題（useEffectのタイミング差など）がないことを確認できたのは意味がある。

### 振り返り

11ファイル新規、18ファイル変更、コンポーネント(.tsx)変更なし。726テスト全パス。作業としては順調だった。

一つ気になるのは、共通hookの行数。ファクトリ関数の型定義が重い。例えば`useDailyPage.ts`は元々各アプリで60行程度だったのが、共通版は113行（deps型定義が30行以上）。依存注入のボイラープレートは避けられないが、「共通化でコードが増える」のは本末転倒感がある。ただ、2アプリで重複していた120行が113行+薄いwrapper×2（計30行）= 143行になったので、行数的にはほぼトントン。メンテナンスポイントが1箇所に集約された価値の方が大きい。

前のセッションで「依存注入で共通化可能だがボイラープレートの価値があるか」と書いた。今回実際にやってみて、50行以上のhooksなら共通化の価値がある、30行以下なら微妙、という感覚を得た。useCreateTaskDialogは30行程度で正直ギリギリのライン。ただユーザーは全部まとめて共通化したかったようなので、一貫性を優先するのは理解できる。
