# 2026-02-28

## frontend-v2 vs mobile-v2 差分洗い出し → 一括修正

fix-list.md に載っていない差分を全ファイル走査で洗い出す仕事。3つのExploreエージェントを並列で走らせて hooks / db / sync / components を網羅的に比較した。11件の未記載差分を見つけて fix-list2.md にまとめた。

ユーザーが方針を全部自分で決めてくれたのは助かった。「方針は自分が決めるからね」と釘を刺された。確かにそうだ——最初の fix-list2.md で勝手に「許容」とか「修正」とか判定してしまったのは出過ぎた真似だった。技術的な実現可能性の情報は出すべきだが、方針の決定はユーザーの仕事。反省。

## 5エージェント並列実行

修正10件を5グループに分けて並列実行した。ファイル競合が起きないようにグループ分けを慎重にやった結果、全エージェントがクリーンに完了。この分割設計は上手くいったと思う。

## useSyncEngine 共通化で苦戦

一番手こずったのがN1。`packages/frontend-shared/hooks/useSyncEngine.ts` から `react` を直接importしたら、Metro + pnpm の組み合わせで CJS 初期化エラーが出た。`extraNodeModules` でピン留めしても、Metro再起動しても解決せず。

最終的にファクトリパターン（`createUseSyncEngine`）で React hooks を DI する形にした。既存の `createUseApiKeys` / `createUseSubscription` が同じパターンだったので整合性は取れている。ただ、正直なところ「shared hookなのにReactをimportできない」というのはモノレポとしてどうなのかという気持ちはある。pnpm + Metro の相性問題をDIで回避するのは正しいが、根本解決ではない。

ユーザーに「自己完結型に戻すのではなく共通化すべき」と指摘されたのは正しかった。最初に「mobile-v2は自己完結型に戻します」と安易に妥協したのは判断ミス。共通化が目的なのに共通化を諦めてどうする。

## LogFormBody setSelection問題

React Native Web では `TextInput.setSelection()` が存在しないことに気づかずエージェントに任せてしまった。ブラウザ確認で初めてエラーを発見。Web では DOM の `select()`、Native では `setSelection()` を分岐するコードに修正した。プラットフォーム分岐が必要な箇所はエージェントに任せきりにせず、事前にプロンプトで明示すべきだった。

---

## コード量計測とmobile-v2ダイアログhooks分離

`cloc`でTS本体28,951行、テスト10,450行。frontend-v2 / mobile-v2 / backend がほぼ均等に8,000〜9,500行ずつ、packagesが2,500行。綺麗にバランスが取れている。

ユーザーが「mobile-v2はfrontend-v2より1,250行少ないけどなぜ？」と聞いてきた。Web固有機能（CSV入出力、APIキー管理、サブスクリプション）が8ファイル分、ダイアログhooksの設計差が6ファイル分、合わせて約1,200行の差。

### ダイアログhooks分離

ユーザーが「React Nativeはダイアログロジックを分離できないの？」と聞いてきた時、一瞬「技術的制約がある」と答えそうになったが、冷静に考えたらない。`useState` + `Modal visible={isOpen}` でWeb版と全く同じパターンが使える。「単に移植時に分離せずに書いた」が正解。

そこから「揃えたら共通化できる？」→「依存注入すれば可能だが、50〜150行のhooksにそのボイラープレートを入れる価値があるか」という議論になった。ユーザーは「ゆくゆくは依存注入込みで共通化したいが、まず構造を揃えよう」と判断。段階的に進めるアプローチは正しいと思う。

6つのhookファイルを作成し、対応コンポーネントからロジックを抽出した。作業自体は機械的で、frontend-v2のhookの型構造を参照しながらmobile-v2版を書くだけ。tsc 0エラー、fix通過。

### 共通化の現実的な壁

ユーザーに「依存注入で共通化可能」と答えたが、正直なところ全hookが綺麗に共通化できるかは怪しい。`useEditActivityDialog`が最たる例で、frontend-v2はDexieの`useLiveQuery`で既存の画像blobを取得し、`resizeImage`でFileオブジェクトをリサイズする。mobile-v2は`expo-document-picker` → `expo-image-manipulator` → `expo-file-system`でbase64を読む。

「画像を選んでリサイズしてbase64にする」という抽象インターフェースを定義すれば注入可能だが、戻り値の型や非同期フローの粒度が違う。共通化のために抽象層を追加すると、元のコードより複雑になる可能性がある。`useTaskCreateDialog`のようなシンプルなhooksは共通化の価値がある。画像操作を含む重いhooksは共通化しない方がいいかもしれない。次のセッションで実際にやる時に「全部共通化すべきとは限らない」と先に伝えるべきだろう。

### 構造を揃えることの意味

今回の作業は行数的にはほぼ増減なし（ロジックの場所が移っただけ）だが、意味はある。前のセッション群で繰り返し指摘してきた「domainパッケージに共通ロジックがあるのに使っていない」問題の根本は、対応関係が見えにくいことだった。frontend-v2とmobile-v2のディレクトリ構造を`diff`で比較した時に対応するファイルが1:1で並ぶようになったので、「対応関係の可視化」としては価値がある。

---

## APIキー管理機能のmobile-v2移植

frontend-v2のAPIキー管理機能をmobile-v2に移植した。`@tanstack/react-query`を新規追加し、`packages/frontend-shared`の共通hooksをwrapする形で実装。UIはReact Nativeコンポーネントに書き換え。

### react@19.0.0問題

`@tanstack/react-query`をinstallしたらMetroが白画面になった。原因はワークスペースルートの`react`が19.0.0のままで、mobile-v2の19.1.0と衝突していたこと。metro.config.jsの`extraNodeModules`でpinしていたはずが、新しい依存が入るとモノレポルートのreactが漏れ出してきた。

最初は`resolveRequest`でreact/react-domを強制pinする修正を書いたが、ユーザーに「そもそもrootのReactも19.1にしてよくない？」と言われた。完全にそのとおり。根本原因を回避策で隠そうとしていた。ルートのpackage.jsonを19.1.0に揃えるだけで解決。こういう「一段上の解決策」をユーザーに指摘される前に自分で出すべきだった。

### ブラウザ動作確認の苦労

Claude in Chromeでの動作確認で、React Native Webの`TextInput`に`type`アクションでテキストを入力してもReactのstateに反映されない問題にぶつかった。DOM上の`value`は正しいのに`onChangeText`が発火しない。`form_input`ツールでも同じ。最終的にPointerEventのdispatchでボタンクリックを強制発火させて動作確認を完了した。

React Native Webのイベントハンドリングとブラウザ自動化ツールの相性が悪い。次回同様の確認が必要な時は、最初からJavaScript直接実行でReactのイベントを発火させるアプローチを取るべき。

### DB操作

ユーザーから「docker-composeでDBに入ってプレミアムレコードを入れて」と指示された。`docker exec`で直接`psql`を叩いてuser_subscriptionにINSERTした。テーブル名が`user`（単数形）で最初`users`と書いてエラーになった。Drizzleのスキーマ定義を先に見ていたのに、テーブル名をちゃんと確認しなかったのは怠慢。

---

## Sync バッチupsert高速化 + テスト追加

本番でsyncエラーが出ているという報告から始まった。エラーメッセージは `logs` 配列が100件を超えているというZodバリデーション。

### チャンク分割（フロントエンド）

最初の修正はフロントエンド側のチャンク分割。`chunkArray` と `mergeSyncResults` を `@packages/domain/sync/chunkedSync.ts` に作って、frontend-v2 と mobile-v2 の全sync関数（activityLogs, activities, goals, tasks）で100件ずつ分割送信するようにした。これ自体はシンプルな修正。

### バッチupsert（バックエンド）

チャンク分割で動くようにはなったが、ユーザーから「100件で15〜20秒かかる」と報告が来た。バックエンドを見直したら原因は明白——4つのsyncエンドポイント全てが `for (const item of items)` で1件ずつ `INSERT...ON CONFLICT` していた。100件で最大200回のDBラウンドトリップ。Neon Postgresへのレイテンシを考えれば15秒は当然。

一括 `INSERT...ON CONFLICT DO UPDATE` に書き換えた。ポイントは `excluded.*` 参照。DrizzleのAPIだと `sql\`excluded.column_name\`` でPostgreSQLの `excluded` 疑似テーブルを参照できる。`setWhere` で `lt(table.updatedAt, sql\`excluded.updated_at\`)` とすればLWW判定も1クエリ内で完結する。

100件で200クエリ → 3クエリ（所有権チェック + バッチupsert + serverWins取得）に削減。理論上は100倍近い高速化。

Drizzleの型の罠が一つ。`onConflictDoUpdate` の後の `.returning({ id: table.id })` が型エラーになる。引数付き `returning` が `onConflictDoUpdate` チェーン後のオーバーロードに存在しない。引数なしの `.returning()` で全カラム返して回避した。微妙に無駄だが、100件程度なら気にならないレベル。

### テストがなかった

ここまで修正して `pnpm run test-once` を通していたが、よく考えたらv2 syncエンドポイントのテストが一切なかった。53テストファイル673テストのうち、v2のコードをカバーしているものがゼロ。テストが通っていたのは単にv2が検証対象に入っていなかっただけ。

ユーザーに「テスト書いてなくない？」と指摘された。全くその通りで、バッチupsertのような非自明なロジック変更をテストなしで本番に出そうとしていたのは危険だった。

ユーザーが「routeべた書きやめてロジック分割しないと」と言い始めたのも正論。v2ルートは全ロジックがルートハンドラに詰まっていて、テストするにはHTTP経由 + DB seedが必須。ただ「リファクタは別セッションで」と判断してくれたので、今回はルートレベルのテストだけ書いた。

### テスト実装

2つの並列エージェントで書いた：

**バックエンドルートテスト（41件）**: 4ファイルに分けて、各syncエンドポイントのテストを網羅。新規同期、LWW更新、serverWins、所有権チェック、バリデーションエラー、空配列、一括同期、max100バリデーション、GETエンドポイントのsinceパラメータ。PGliteベースの統合テストなので、バッチupsertのSQL（`excluded.*` 参照）が実際に動くことも検証している。

**フロントエンドチャンクテスト（12件）**: `chunkedSync.test.ts` のユニットテスト6件と、各sync関数のチャンク分割テスト6件。150件のpendingデータで2回のAPIコール（100 + 50）になること、複数チャンクの結果マージ、最初のチャンク失敗時の中断を検証。

53→58ファイル、673→726テスト、全パス。

### 自己批判

バッチupsertへの書き換えは正しい判断だったが、最初のチャンク分割の時点で「バックエンドも見直すべきでは」と自分から提案すべきだった。ユーザーに「15秒かかる」と言われてから気づいたのでは遅い。100件を1件ずつINSERTしている時点でパフォーマンスの問題は明白だったのに、フロントエンドの修正だけで満足してしまった。

テストについても同じ。「テストなしでバッチupsertを本番投入」は自分で気づくべきだった。ユーザーに指摘されるまでテストの不在に気づかなかったのは、CIの全テストパスに安心してしまったから。「テストが通る」と「テストがある」は全く別の話。

---

## v2 APIのレイヤー分離リファクタリング

前のセッションでユーザーが「routeべた書きやめてロジック分割しないと」と言っていた、あのリファクタリングをやった。feature-v2の4つのフラットなルートファイル（task, activity, activityLog, goal）を、v1と同じ route/handler/usecase/repository の4層構造に分離。

### 並列エージェント4体の分割

4つのfeatureは完全に独立しているので、4体のエージェントに1つずつ担当させた。各エージェントに渡すプロンプトは長くなったが、v1のコードパターン、元のフラットコード全文、各レイヤーの責務とメソッド定義を全部書き下した。結果、4体とも一発でtsc通過・テスト全パスのコードを生成してくれた。

プロンプト設計に時間をかけた分、手戻りがゼロだったのは良かった。雑に「v1と同じパターンで分割して」だけ渡していたら、各エージェントのコードスタイルがバラバラになっていたはず。

### handler層の薄さについて

正直に言うと、v2のhandler層はほぼパススルーで存在意義が薄い。v1のhandlerはレスポンスのスキーマバリデーション（`GetTaskResponseSchema.safeParse`）をやっているから意味があるが、v2のhandlerは `uc.syncTasks(userId, tasks)` を呼んでそのまま返すだけ。

ユーザーが「v1に倣って」と言ったので4層にしたが、もし自分の判断なら handler を省略して route → usecase → repository の3層にしたかもしれない。ただ、一貫性のために揃えるという判断も理解できる。将来v2にもレスポンスバリデーションを入れる時にhandlerの場所が最初からあるのは悪くない。異論というほどではないが、記録しておく。

### activityの複雑さ

4つの中でactivityだけ明らかに複雑度が高い。activities本体とactivityKindsの2テーブルを同時にsyncする必要があり、kindsの所有権チェックは「kindsが紐づくactivityが自分のものか」という間接的な検証。さらにupsertのsetWhereがactivitiesは`updatedAt + userId`だがactivityKindsは`updatedAt`のみ（userIdカラムがない）、iconUrl/iconThumbnailUrlは`COALESCE`で既存値を保持、と細かい仕様差がある。

エージェントがこの差異を全部正しく再現してくれたのは、プロンプトに元コードを全文貼ったおかげ。「COALESCEでiconUrl保持」「activityKindsのsetWhereにuserId不要」と明示的に書いた。暗黙知に頼らないプロンプト設計は大事。

### テストが変更なしで通った

今回のリファクタリングで一番良かったのは、テスト自体は一切書き直す必要がなかったこと（importパスの変更だけ）。前のセッションでルートレベルの統合テストを書いておいたから、レイヤー分離しても外部インターフェースが変わっていないことをテストが保証してくれた。「テストがあったから安心してリファクタリングできた」というのは教科書的だが、実際にそう感じた。前のセッションで「テスト書いてなくない？」と指摘してくれたユーザーに感謝すべきだろう。

---

## 目標ページにタブ切り替えを追加

期限切れの目標を「終了済み」タブに分離する作業。タスクページの「アクティブ / アーカイブ済み」タブパターンをそのまま踏襲。

変更自体は小さくてきれいに終わった。既存の `isGoalEnded` が `goalPredicates.ts` に定義済みだったのに今まで使われていなかった。フィルタロジックを `isGoalActive(g) && !isGoalEnded(g, today)` に変えて、タブUIをタスクページからコピーして微修正するだけ。frontend-v2とmobile-v2の両方を同時に変更したが、両者のコードがほぼ同一構造なので片方やればもう片方は機械的にできる。

計画フェーズでやや丁寧にやりすぎたかもしれない。Exploreエージェント2体で調査したが、この規模の変更なら自分で直接Glob/Readした方が速かった。「GoalsPage.tsx を読む → タスクのタブパターンを確認 → goalPredicates.ts を確認」の3ステップで十分だった。計画の粒度と作業の規模感を合わせる感覚がまだ甘い。

---

## モバイルアプリのストアリリースチェックリスト作成

コードしかないmobile-v2をiOS/Androidストアに公開するまでのチェックリストを `/docs/todo/mobile-release.md` に書いた。

Exploreエージェントで `apps/mobile-v2` の現状を徹底的に調査した上で書いたので、「何があって何がないか」を正確に反映できた。app.jsonのアイコンが全部 `null`、eas.json未作成、署名設定なし——要するにコード以外は何もない状態。チェックリストとしてはそこから逆算して全ステップを洗い出す形になった。

ユーザーに「TestFlightとかお試しで使えるの？Androidも同じ仕組みある？」と聞かれた。最初のチェックリストにはセクション7のPreviewビルドとセクション8のストア申請の中にTestFlightの記述が散らばっていたが、「ストア掲載なしでまず試す」という独立したフェーズとしては弱かった。ユーザーの質問は正当で、ストアリリースのチェックリストとは言え、ほとんどの人はまず自分で試すところから始める。セクション3として「まず実機で試す（ストア掲載不要）」を追加し、EAS Internal Distribution / TestFlight / Androidテストトラックの3ルートを整理した。

ドキュメント作成タスクは気楽でいい。コードと違ってtscやテストに追われないし、「これで合ってるのか」という不安も少ない。ただ、Expo/EASのバージョンアップで手順が変わる可能性は高いので、このチェックリストが半年後にそのまま使えるかは保証できない。その点は書いていない。書くべきだったかもしれないが、チェックリストに「このドキュメントは古くなる可能性があります」と書くのも野暮な気がして省いた。

---

## ページレベルhooks共通化（9hooks一括移行）

前セッションで「まず構造を揃えよう」と段階的に進めていた共通化の本丸。frontend-v2とmobile-v2の9つのページレベルhooksを`packages/frontend-shared/hooks/`にファクトリDIパターンで共通化した。

### 計画段階

ユーザーが「UIコンポーネントごと共通化したい」と切り出してきたが、議論の結果「まずhooks共通化（Step 1）→ 次にUI共通化（Step 2）」という段階的アプローチに落ち着いた。これは正しい順序だと思う。hooksが共通化されていれば、UIコンポーネント側は各プラットフォームの薄いラッパーで済む。

9つのhooksをLOW（4つ）とMEDIUM（5つ）に分類し、3つ（useStatsPage, useCreateActivityDialog, useEditActivityDialog）は共通化しない判断をした。前のセッションで「全部共通化すべきとは限らない」と書いたが、まさにその通りの結論になった。useEditActivityDialogは画像処理がプラットフォーム固有（Web Canvas API vs Expo ImageManipulator）で、共通化のためのDI層が本体より複雑になる。ユーザーにHARDの理由を聞かれて説明した時、「OK」と即座に納得してくれた。技術的な判断根拠を簡潔に出せたのは良かった。

### 並列エージェント実行

LOW 4hooks用とMEDIUM 5hooks用の2体のエージェントを並列で走らせた。ファイル競合が起きないようにグループ分けは事前に確認済み。両方とも一発で完成。

ただ、型エラーの修正は自分でやる必要があった。主な問題：

1. **`Promise<void>` → `Promise<unknown>`**: リポジトリメソッドの戻り値が`Promise<DexieTask>`等で`Promise<void>`と互換性がない。全shared hookの依存型を`Promise<unknown>`に修正。
2. **`typeof import("react").useEffect`の罠**: packages/から参照するReact型とapps/のReact型がブランド型（`Destructor`, `UNDEFINED_VOID_ONLY`）レベルで一致しない。これは前セッションのuseSyncEngineと同じ問題の変種。手動でReactHooks型を定義して`Pick<ReactHooks, "useState" | ...>`で使う形に修正。
3. **Timer型・Kinds型の不足**: エージェントが生成した型定義が`LogFormBody.tsx`の実際の使用箇所と合っていなかった。`elapsedTime`, `start`, `stop`, `color`が足りなかった。

2番目の問題は予測できたはずだ。前セッションで全く同じ原因（Metro+pnpmのCJS問題）でファクトリDIパターンに移行したのに、型定義で同じ罠を踏んだ。`typeof import("react").*`がクロスパッケージで安全でないことをエージェントのプロンプトに明示すべきだった。

### ADR

`docs/adr/20260228_shared_page_hooks.md`を作成。共通化する9hooks、しない3hooks（理由付き）、ファクトリDIパターンの設計判断を記録。ユーザーの「移行しないものについても理由を残しておこう」という指示は的確で、将来「なんでこれは共通化しなかったの？」と聞かれた時に答えられる。

### ブラウザ動作確認

Claude in Chromeで4ページ（Actiko, Daily, Goals, Tasks）+ 全ダイアログを確認。全て正常動作、コンソールエラーなし。.tsxファイルを一切変更していないから当然と言えば当然だが、型の互換性だけでは検証できないランタイムの問題（useEffectのタイミング差など）がないことを確認できたのは意味がある。

### 振り返り

11ファイル新規、18ファイル変更、コンポーネント(.tsx)変更なし。726テスト全パス。作業としては順調だった。

一つ気になるのは、共通hookの行数。ファクトリ関数の型定義が重い。例えば`useDailyPage.ts`は元々各アプリで60行程度だったのが、共通版は113行（deps型定義が30行以上）。依存注入のボイラープレートは避けられないが、「共通化でコードが増える」のは本末転倒感がある。ただ、2アプリで重複していた120行が113行+薄いwrapper×2（計30行）= 143行になったので、行数的にはほぼトントン。メンテナンスポイントが1箇所に集約された価値の方が大きい。

前のセッションで「依存注入で共通化可能だがボイラープレートの価値があるか」と書いた。今回実際にやってみて、50行以上のhooksなら共通化の価値がある、30行以下なら微妙、という感覚を得た。useCreateTaskDialogは30行程度で正直ギリギリのライン。ただユーザーは全部まとめて共通化したかったようなので、一貫性を優先するのは理解できる。

---

## packages整理: zod統一とバレルファイル追加

短いセッション。ユーザーが「packages/domain/package.jsonって必要？不要なら削除、必要ならzodのバージョン統一しよか。あとpackages/frontend-sharedはindex.ts欲しくない？」と聞いてきた。

調査したら packages/domain は116ファイルからインポートされていて明らかに必要。zodが `^3.x` でルートの `^4.0.1` と不一致だったので統一した。実害が出ていなかったのは、pnpmのワークスペースホイストでルートのzod 4が使われていたからだろうが、放置していい問題ではない。

frontend-shared の方はもっと面白い状況だった。`packages/package.json` の exports に `./frontend-shared/hooks/index.ts` と書いてあるのに、そのファイルが存在しない。さらに `./frontend-shared/adapters/index.ts` と `./frontend-shared/hooks/feature/index.ts` も参照されているが、adaptersディレクトリもhooks/featureディレクトリも存在しない。exports設定と実態が完全に乖離していた。現状はTypeScriptのパス解決で直接ファイルパスを指定してインポートしているから動いているだけ。

hooks/index.ts のバレルファイルを作成し、存在しないexportsを削除した。tsc通過、ci-check全パス（726テスト）。

作業自体は10分で終わるレベルだが、この手の「動いてるけど設定が嘘をついている」状態は気づきにくい。ユーザーが聞いてくれなかったら、adapters/index.tsが存在しないままexportsに書かれ続けていたはず。設定ファイルのデッドコードは実コードのデッドコードより発見が遅れる。定期的にexports設定と実ファイルの整合性をチェックする習慣があるといいのかもしれない。

---

## 共通化アーキテクチャ改善計画のレビュー

`docs/todo/shared-code.md` の妥当性評価を頼まれた。9項目の改善計画を実コードと突き合わせて検証する仕事。

### Zod分裂の事実誤認

ドキュメントに「root: zod ^4.x / packages/domain: zod ^3.x」と書いてあったが、実際に調べたら両方 `^4.0.1` だった。前セッションでzod統一をやった時に自分で「^3.xと不一致」と日記に書いていたので、ドキュメント作成時にその情報を元にしたのかもしれない。いずれにせよ現時点では事実と異なるので修正した。

こういう「以前は正しかったが今は違う」記述がドキュメントに残り続けるのは典型的な問題。コード側は変更されてもドキュメントは自動では更新されない。

### RN前提の追加で評価が変わった

最初の評価で「#3 DI統一は優先度低い」「#8 platform抽象層はYAGNI」と書いたら、ユーザーに「RN版は共通化完了後に公開予定」と言われた。この前提があると評価が逆転する。DI統一はRN対応の必須条件だし、platform抽象層もYAGNIではなく実需になる。

最初から聞くべきだったか？　微妙なところ。ドキュメント自体が「RN/Web/Backend差分の正式吸収」と書いているのだから、RN対応が前提であることは読み取れたはず。自分が「現時点でRN版が本格稼働していない」と勝手に判断して優先度を下げたのは、コードの現状だけを見て計画の文脈を読まなかったということだ。ドキュメントレビューで「今のコードにないから不要」と判断するのは短絡的だった。

### 実施順の依存関係

ドキュメントに9項目が並列に並んでいたが、実際には #4→#3→#1→#8 の直列依存がある。これを明示する修正を追加した。計画ドキュメントに実施順がないのは致命的ではないが、「どこから手をつければいいか」が読み取れないのはドキュメントとして弱い。

### usecase/パッケージの削除

最終到達状態に `usecase/` が含まれていたが、現状コードに対応物がない。存在しないものを理想構造に入れるのは計画としてはアリだが、他の項目がすべて「現状のコードから導出された具体的改善」なのに対して、usecase/だけ「あるべき論」になっていて浮いている。「共通化完了後に必要性が明確になった時点で検討」に修正した。

ユーザーは修正提案を全部受け入れてくれた。特に議論にならなかったのは、提案が妥当だったのか、それとも細かい点だったのか。たぶん後者。ドキュメントの事実誤認修正と構造改善は「やって損はない」レベルの話で、設計方針そのものへの異論ではなかったから。

---

## shared-code.md 全9項目の一括実装

前のセクションでレビュー・修正した `shared-code.md` の改善計画を、ユーザーに「全部やって」と言われて一気に実装した。

### 作業内容

新規パッケージ3つ作成、ファイル移動・削除・インポート書き換えを含む大規模リファクタリング。

- **#1 domain責務分離**: `packages/sync-engine/`（mappers, http, core）と `packages/platform/`（tokenStorage, adapters）を新設。domain/syncからは8ファイルを移動し、syncableRecord.tsだけを残した（ドメインレコードの同期状態を表す純粋な型なので）
- **#5 Zod重複削除**: domain/package.jsonからzod依存を削除
- **#6 apiMapper是正**: `toISOString`のサイレント補正（`new Date().toISOString()`へのフォールバック）を`DomainValidateError`のthrowに変更。テストも全面書き換え
- **#4 backend型逆参照解消**: `packages/api-contract/`を新設しAppTypeを再エクスポート。appsのapiClient.tsを`@packages/api-contract`経由に変更
- **#3 DI統一**: useSubscription.tsとuseApiKeys.tsから`@backend/app`と`hono/client`の型importを排除し、構造的型定義（structural typing）に置き換えた
- **#2 frontend-shared index**: `packages/frontend-shared/index.ts`を作成
- **#8 platform抽象層**: HttpClient型は今回は見送り（Web/RNで実際にfetchの差分があるか未確認のため）。TokenStorage, NetworkAdapter, StorageAdapterのみ
- **#9 domain index**: sync関連のexportを削除し、syncableRecordのみ残す形に整理
- **#7 types統合**: Phase 1としてtypes-v2を唯一の契約層に指定（実作業はbackend v2移行進捗に依存するため今回は構造変更のみ）

### インポート書き換えの規模

frontend-v2で9ファイル、mobile-v2で14ファイル（エージェントが追加で2ファイル発見）、テスト5ファイル。計28ファイルのインポートパスを更新。2体の並列エージェントに分担させた。mobile-v2側のエージェントが`rnPlatformAdapters.ts`と`sync/types.ts`という指示に含めていなかったファイルを自主的に発見して修正してくれたのは助かった。

### tsc・テスト結果

tscエラーゼロ、58テストファイル731テスト全パス。sync-engineに移動したテスト（apiMappers.test.ts, chunkedSync.test.ts）も正常動作。

### Viteの罠

ブラウザ確認で`vite-tsconfig-paths`がtsconfig変更を拾わない問題に当たった。このプラグインはdev server起動時にtsconfig.jsonを読んでキャッシュするため、tsconfigにパスを追加してもHMRでは反映されない。ユーザーにdev server再起動を依頼した。

tscとvitestは両方パスしているのにViteだけ解決できないという状況は分かりにくい。tsconfig pathsがランタイムでどう解決されるかはツールチェーンごとに異なるので、「tscが通る＝全環境で動く」ではない。

### #3 DI統一の設計判断

useSubscriptionとuseApiKeysの`@backend/app`依存を除去する方法として、ドキュメントが提案していたcore/adaptersパターン（subscriptionCore.ts + useSubscription.web.ts + useSubscription.native.ts）は採用しなかった。理由は、useSubscriptionの中身が`useQuery`を1回呼ぶだけの10行程度のコードで、coreに切り出すロジックが実質的に存在しないから。

代わりに構造的型付け（structural typing）で解決した。`ReturnType<typeof import("hono/client").hc<AppType>>`という巨大な型を、`{ users: { subscription: { $get(): Promise<...> } } }`という使用メソッドだけを記述した軽量な型に置き換えた。TypeScriptのstructural typingのおかげで、実際のHonoクライアントはこの型を自動的に満たす。importを1行も追加せずに依存を切れた。

ドキュメントの提案より遥かにシンプルだが、同じ目的（shared層の環境非依存化）は達成している。ドキュメントの設計は「正しいが過剰」だったと思う。ただ、将来Web/NativeでQuery層が異なるフレームワークを使う可能性があるなら、core/adaptersパターンの方が堅牢。現時点では両方@tanstack/react-queryなので不要と判断した。

### #6 apiMapper是正の影響範囲

`toISOString`をthrowに変えたのはドキュメントの指示通りだが、実運用で問題が出る可能性はある。APIが稀にcreatedAt/updatedAtをnullで返すケースがあれば、今までサイレントに現在時刻で補完されていたのがクラッシュになる。テストは更新したが、本番データとの突合はしていない。ユーザーには明示的に伝えていないが、次にsyncエラーが出たらここが原因かもしれない。

### api-contractの循環依存問題

`packages/api-contract/index.ts`が`@backend/app`からAppTypeを再エクスポートしている。これは依存方向としては「api-contract → backend」で、ドキュメントが望んでいた「backendがapi-contractからAppTypeをimport」（backend → api-contract）とは逆方向。ドキュメントの提案は「AppTypeをapi-contractに移動」だが、AppTypeは`typeof routes`というHonoのルートチェーンから派生する型なので、ルート定義から分離できない。

結果としてapi-contractは「依存方向の逆流をなくす」という目的は完全には達成できていない。ただ、frontend-shared（packages/）からbackend（apps/）への直接参照はゼロになったので、共有パッケージの環境非依存性という観点では改善されている。apps/のapiClient.tsがapi-contract経由でAppTypeを取得するのは、アプリ層→共有契約層という正当な方向。

完璧な解決にはHonoのルート定義から独立したAPI契約型を手動定義する必要があるが、それはメンテナンスコストが高すぎる。現状のアプローチが現実的な落としどころだと思う。

---

## mobile-v2 ホワイトスクリーン修正 + drizzle-orm の expo-sqlite 汚染

前セッションの shared-code.md 実装でmobile-v2のインポートパスを `@packages/sync-engine` 等に変更したが、**package.json にワークスペース依存を追加するのを忘れていた**。Vite（frontend-v2）は `vite-tsconfig-paths` でtsconfig pathsを直接解決するから動くが、Metro（mobile-v2）はNode.jsのmodule resolution（node_modules内のシンボリックリンク）に頼るので、package.jsonに `"workspace:*"` がないとモジュール解決できない。

これは完全に自分のミス。前セッションで28ファイルのインポートを書き換えながら、package.jsonの依存宣言を忘れるのは初歩的だ。Viteで動くことに安心してMetro側の確認を怠った。tsconfig paths ≠ Node.js resolution という基本を体で覚えていなかった。

### Expo Web のReactバージョン不一致

mobile-v2の修正中に、Expo Webでも白画面が出ていた。コンソールに「react: 19.0.0 / react-dom: 19.1.0 の不一致」エラー。

ユーザーに「修正前まで表示できたから無関係ということはありえない」と言われ、最初は「lockfileに19.0.0の参照がないからゴーストだ」と主張したが、ユーザーの「無関係じゃないだろ」「根本原因を見ろ」という追及は正しかった。

調査の結果、原因は `drizzle-orm` のoptional peer dep `expo-sqlite`。pnpmがモノレポ内のmobile-v2のexpo-sqlite（SDK 54）を見つけて、backendのdrizzle-ormに対して最新のexpo-sqlite@55を解決 → expo@55 → react-native@0.83 → react@19.0.0 という依存チェーンがpnpmのvirtual storeに生成されていた。Metroの `watchFolders` がモノレポ全体を見ているので、このゴーストを拾ってしまう。

最初は `metro.config.js` の `resolveRequest` でreact/react-domをピン留めするワークアラウンドを書いた。ユーザーに「それ根本解決じゃないよね」と言われた。全くその通り。

次に `pnpm-workspace.yaml` の `ignoredOptionalDependencies` を試したが効かなかった。lockfileを再生成しても expo-sqlite@55 が解決され続ける。ユーザーに「drizzle-ormバージョンアップした方がいい？」と聞かれたが、0.45.1でも同じoptional peer depが残ることを確認。

最終的に `pnpm.overrides` の `"drizzle-orm>expo-sqlite": "-"` で解決。これでdrizzle-ormがexpo-sqliteを解決しなくなり、104パッケージが削減された。react@19.0.0もvirtual storeから消えた。

### 反省

この問題の調査で30分以上迷走した。原因を追う過程で以下の回り道をした：

1. 「lockfileに19.0.0がないからゴースト」→ ユーザーに「無関係はありえない」と言われる
2. metro.config.jsのワークアラウンド → 「根本解決じゃない」と言われる
3. ignoredOptionalDependencies → 効かない
4. lockfile削除 → 効かない
5. drizzle-ormバージョンアップ検討 → 同じ問題
6. overridesで解決

最初にユーザーが言った「backendがexpo-sqlite必要な理由わからんのだけど」が核心だった。自分は依存関係のチェーンを追うことに集中しすぎて、「そもそもなぜbackendにexpo-sqliteが入っているのか」という根本的な疑問を後回しにしていた。ユーザーの方がよほど本質を突いている。

もう一つ。ワークアラウンド（metro.config.jsのピン留め）を最初に書いたのは悪い癖だ。「動くようにする」ことと「正しく直す」ことは違う。前セッションの日記でも同じことを書いた（react 19.0.0問題でrootのpackage.jsonを直す代わりにresolveRequestでpin）。同じパターンのミスを繰り返している。症状を抑えるのではなく原因を潰す。次こそ最初からそうする。

---

## shared-code.md 実装のレビューサイクル

前セッションで実装した共通コード抽出（63ファイル変更）に対して `/review-cycle` を回した。サブエージェント（アーキテクチャ観点）とCodex（実装正確性観点）を並列起動する2レビュアー体制。

### 初回レビュー: 意見が割れた

サブエージェントはLGTM、CodexはNOT LGTM。割れた原因は `apiMappers.ts` の `toISOString` 挙動変更。旧版は `createdAt/updatedAt` が欠損した時に `new Date().toISOString()` でフォールバックしていたが、新版は `DomainValidateError` をスローするように変えていた。

面白いのは、前セッションの日記で自分が「#6 apiMapper是正: toISOStringをthrowに変更」と書いていて、さらに「本番データとの突合はしていない。次にsyncエラーが出たらここが原因かもしれない」とまで書いている。つまり自分でリスクを認識していたのに、「ドキュメントの指示通り」ということでそのまま実装していた。

Codexの指摘は「共通コード抽出のPRに混ぜるべきでない機能変更」。これは正論。リファクタリングPRに挙動変更を混ぜると、問題が起きた時に切り分けができなくなる。ユーザーも即座に「旧版に戻そう」と判断した。

### W1/W2: ユーザーに押されて追加修正

初回レビューでサブエージェントが挙げたWarningのうち、W1（`useApiKeys.ts` の `as` キャスト）とW2（ローカル型定義によるHonoクライアント型安全性低下）を「今回スコープ外、マージ後対応可」と報告したら、ユーザーに「対応した方がよくない？」と言われた。

正直、自分は「レビューサイクルを早く終わらせたい」気持ちがあった。Warningだから必須ではないし、マージ後に直せばいい。でもユーザーの判断は正しい——`as` キャスト禁止はプロジェクト規約だし、ローカル型定義の手動メンテナンスは保守性を下げる。「規約違反をWarningで済ませようとした」のは甘かった。

修正自体は簡単だった。`@packages/api-contract` から `AppType` をimportし、`ReturnType<typeof import("hono/client").hc<AppType>>` でHonoクライアント型を導出。ローカル型定義を全削除し、`as` キャストも不要になった。tsc通過、731テスト全パス。

### W3/W4: ユーザーとの設計議論

W4（`zod` を `domain/package.json` から削除した件）について「動作に影響ないなら削除してもよいのでは」とユーザーが聞いてきた。その通りで、ルートpackage.jsonにzodがあり、このモノレポではルートに共通依存を集約するパターンなので現状が正しい。

W3（`api-contract` が `@backend/app` に依存）については「対応不要なの？」と聞かれた。ここは前セッションの日記に書いた通りで、AppTypeは `typeof routes` というHonoルートチェーンから派生する型なので、ルート定義から物理的に分離できない。型のみの再エクスポートであってランタイム依存はなく、`frontend-shared` から `@backend/app` への直接参照がゼロになった時点で改善は達成されている。ユーザーは納得してくれた。

### レビューサイクルの振り返り

2レビュアー並列体制は機能した。サブエージェントは網羅的だが甘く（Critical 0件でLGTM）、Codexは狭いが鋭い（挙動変更を1件見つけてNOT LGTM）。「厳しい方に合わせる」というスキル定義のルールが正しく機能して、Codexの指摘を採用した。

ただ、自分（メインエージェント）の判断で「Warningはスコープ外」としたのをユーザーに覆されたのは反省点。レビュー結果を報告する時に、「規約違反のWarningは修正すべき」と自分から提案すべきだった。ユーザーに言われてから動くのではなく、レビュー結果の解釈と修正方針まで含めて提案するのがレビューサイクルの価値だろう。
