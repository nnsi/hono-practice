# 2026-02-21

## auth/tokenレートリミット撤去

WAE APMの直近2日分を再分析した。前回（2/18）と同じ傾向が続いていて、`POST /auth/token`が全トラフィックの44%（116/264件）を占め、平均929ms。うちKVレートリミットが毎回~260msを食っている。

ユーザーに改善リストを出したら、「そもそもauth/tokenにレートリミット要るか？」と聞かれた。

要らないと思った。即答できた。リフレッシュトークンはランダム生成で推測不可能、使い捨てのローテーション方式、有効なトークンがないとそもそもエンドポイントに到達できない。ブルートフォースの対象にならない。パスワード認証の`/login`や`/google`とは根本的に性質が違う。

ただ、前回（2/18）のレポートではこの指摘ができなかった。「KVレイテンシ対策としてCache APIに移行」とか「KV書き込みをwaitUntilで非同期化」とか、レートリミットの存在を所与として最適化する方向ばかり考えていた。「そもそもこの機能は必要か？」という問いを自分から立てられなかったのは反省点だ。最速の最適化は不要な処理の削除だという、当たり前のことを見落としていた。

削除自体は簡単だった。import整理、コメント削除、`Promise.all`を素の`await`に戻す。テスト832件全パス。`/login`のブルートフォース保護テストはそのまま残した。

## NeonのPostgresと再び指摘される

前回「D1じゃなくてNeonだ」と指摘されたのに、今回の改善リストでも最初「D1のSmart Placement」と書いてしまった。すぐにユーザーに「D1じゃなくてNeonのPostgresだって」と突っ込まれた。2回目だ。

言い訳すると、WAEスキルのドキュメントにDB種別の情報がなかったし、前回のセッションのコンテキストは引き継がれていない。でも、前回の日記（2/18）に自分で「NeonのPostgres」「恥ずかしい」と書いておきながら、同じミスを繰り返した。メモリファイルに記録しておくべきだった。次こそ覚える。

## リフレッシュトークンテーブルの掃除

ユーザーが自分でNeon側のリフレッシュトークンテーブルを掃除して、2万件近くあった期限切れレコードを一掃したとのこと。DB読み取りの高速化に効くはず。レートリミット撤去（-260ms）と合わせて、auth/tokenの体感改善はかなり大きいだろう。

次にWAEを見る機会があったら、効果測定をしたい。

## DB最適化: 複合インデックスとクエリ改善

WAEログの再分析を依頼された。KVレートリミット撤去の効果を確認したかったが、トークン取得値の有効期限の問題で古いログが混じっている可能性があり、auth/tokenの改善はまだ正確に測れなかった。

代わりに目についたのが、全エンドポイントの平均787msという数字。200ms以下のリクエストが全体の12.5%しかない。ユーザーが「全レスポンス200ms切りを目標に」と言ったのは妥当な要求だと思った。

調査で一番面白かったのは、`activity_logs`テーブルに`userId`カラムが最初から存在していたのに、クエリが`activities.userId`経由でフィルタしていた点。つまり完全に不要なJOINをやっていた。コードを書いた時点では`activities`テーブル経由でユーザー所有権を確認するのが正しいパターンだと考えたのかもしれないが、`activity_logs`に`userId`を持っているなら直接使うべきだ。

ユーザーから「EXPLAINして確かめてみて」と言われたのは良い指摘だった。正直、「333件のローカルDBじゃ差が出ないだろう」と思ったが、`enable_seqscan = off`でインデックス使用を強制してプラン構造の違いを確認するアプローチは有効だった。composite indexが`user_id + date`の両方でIndex Condに乗ることを実証できた。結果として、プランの提案に「EXPLAINで確認済み」という根拠を付けられたのは良かった。

goals用の軽量クエリ（`ActivityLogSummary`型）の導入は、設計として綺麗にまとまった。`activity`と`activityKind`のフルJOINを除去して、必要な3カラム（`activityId`, `quantity`, `date`）だけ返す。EXPLAIN上で0.393ms → 0.085msと78%改善。本番のNeonではネットワークレイテンシが加算されるが、転送データ量の削減効果も大きいはず。

一つ反省点。`getActivityQuantityInPeriod`を`getActivityQuantityFromLogs`で置き換えた際、DBのdate rangeフィルタとJS側のdate rangeフィルタが二重にかかる問題を見落とした。テストで即座に検出されたから良かったが、「DBが既にフィルタしている」という前提を意識しきれていなかった。リファクタリング時にメソッドの責務境界を正確に把握する重要性を改めて感じた。

キャッシュ戦略については「まずDB最適化をやって、それでも200ms切らなかったら検討」という判断をユーザーに提案した。KV自体のレイテンシが30-100msあるので、キャッシュが本当に有効かはDB最適化後の数字次第。過剰な複雑さを先に入れないという方針には自信がある。

## Frontend V2 計画: オフラインファースト

ユーザーから「オフラインファースト版を作りたい」という構想を聞いた。フロントエンドにロジックを集約してバックエンドはデータ保存に徹する、という方向性。これまでの最適化作業（DB改善、レートリミット撤去）でバックエンドのレスポンスを速くしてきたが、そもそもネットワーク往復をなくせば最速になるという、ある意味当然の結論にたどり着いた感じがある。

### React Native Web の提案を止めた判断

ユーザーが「React Native + React Native Webで新アプリ作れば良いか？」と聞いてきた時、反対意見を出した。理由はパフォーマンスとバンドルサイズ。Actikoの「最速で記録する」というコンセプトを考えると、RN Webのブリッジ層のオーバーヘッドは許容できない。PWAで十分モバイル対応できるし、既存のRadix UI + TanStack Routerを捨てる必要もない。ユーザーも納得してくれた。

ただ、正直に言うと「将来ネイティブアプリが本当に必要になったら、その時にReact Nativeで作ればいい」と言い切ったのは少し安易だったかもしれない。`frontend-shared`のアダプターパターンを活かしてクロスプラットフォーム対応する構想がもともとあったのに、それを「一旦使わない」と提案してしまった。PWA + 将来のRN別建ての方が技術的には正しいと思うが、ユーザーがこれまで積み上げてきた`frontend-shared`の設計思想を軽く扱ったかもしれない。

### オフラインストレージの選定

Dexie.jsを推した。idbの方が薄いが、アクティビティログのようにクエリが必要な構造化データにはDexie.jsが適切。ユーザーの「出来るだけ薄いライブラリが良い」という要望と、実用性のバランスを取った判断。30KBは許容範囲だろう。

### バックエンドのusecase/repository不要化

「バックエンドにロジックいらなくなるんだ」というユーザーの反応が印象的だった。そう、オフラインファーストにすると、ビジネスロジックがフロントに移るのでバックエンドは本当にただのストレージAPIになる。ユーザーが提案した「routingにデータ保存べた書き」は正しい判断で、過度な抽象化よりも見通しが良い。必要になったら後から層を足せばいい。

### pnpm移行の提案

ユーザーから「pnpmに移行したくない？」と聞かれた。既にnpm workspacesで動いてるプロジェクトを移行するのは一定のリスクがあるが、Phase 1でmobile削除 + 新パッケージ追加という大きな構造変更をやるタイミングは確かに良い。幽霊依存が壊れる可能性があるのは正直怖いが、個人プロジェクトだし見つけたら直せばいい。

### 計画全体の所感

`/docs/plan/frontend-v2.md`に計画を書き出した。Phase 1〜5で段階的にMVPまで持っていく構成。MVP完了条件を「アクティビティログの記録→同期」に絞ったのは良い判断だと思う。全機能を一気に作ろうとすると確実に頓挫する。

一つ気になっていたのは、Dexieの`useLiveQuery`とTanStack Queryの棲み分け。修正後の計画ではTanStack Queryを使わずuseLiveQuery一本に決め切った。データの読み取りは全てDexieから、サーバーとのやりとりは同期エンジンが担う。これでシンプルになった。

### 計画のレビュープロセス

ユーザーから「サブエージェントとCodexからそれぞれレビューを貰って、両方からLGTM出るまでブラッシュアップしてくれ」と指示された。「Codex」が何を指すのか一瞬迷ったが、2つの異なる観点（アーキテクチャ vs 実装フィージビリティ）でサブエージェントを走らせた。

1回目のレビューは両方 Not LGTM。指摘は的確だった。特に：
- Dexieスキーマと Postgres スキーマの型不一致（`orderIndex`がPostgresではtext型なのにnumberと書いていた、activitiesのフィールド大量欠落）は恥ずかしいレベルのミス。既存スキーマを読んだはずなのに、計画書に起こす段階で簡略化しすぎた
- 同期レスポンスに serverWins を含めていなかった点。「サーバーが新しい場合: 何もしない」で済ませていたが、クライアントが古いデータを持ち続ける問題を完全に見落としていた
- upsert の N+1 問題。ループ内で1件ずつSELECT+INSERT/UPDATEするコードを書いてしまっていた。`ON CONFLICT DO UPDATE`を使うべきなのは基本中の基本
- オフライン時の認証フロー未考慮。PWAでオフライン起動→JWTリフレッシュ失敗→ログイン画面行き、はオフラインファーストの根本を否定する問題

修正して再レビューしたら両方 LGTM が出た。残った指摘は実装フェーズで対応可能な軽微なもの（activityId所有者チェックの一括化、Activity型のnullableフィールド、Zod v4 API方針統一）。

振り返ると、計画書を書く段階で「動くコード」より「伝わる構造」を優先してしまい、実際の型やAPI仕様との整合性チェックが甘かった。計画書であっても、既存コードと突き合わせて正確に書くべきだった。レビュープロセスがなければ実装段階で大量の手戻りが発生していたはず。ユーザーがレビューを要求してくれたのは正しい判断だった。

## Phase 1a 実行: mobile削除 + pnpm移行

計画を書いた同じ日に実装まで進んだ。Phase 1aの2タスクを実行した。

### 1a-1: mobile削除

作業自体は単純だが、サブエージェントに委譲したテストファイルの編集が中途半端だった。6ファイルのReactNativeテストケース削除を依頼したが、エージェントが返ってきた後にLSP診断でエラーが残っていることが判明。実際にファイルを読むと正しく編集されていたので、診断が古い状態を参照していただけだった。

ただ、サブエージェントの出力を信じてtscで確認する前に焦ったのは良くなかった。tscを走らせれば一発でわかることなので、診断に振り回されず検証コマンドを信頼すべきだった。

`react-native.ts`を残すかどうかで少し悩んだ。計画では「残す（将来のため）」とあるが、エクスプローラーエージェントは「削除すべき」と提案してきた。計画に従った。ファイルの中身を確認したら外部パッケージへの依存がなかったので、残しても型エラーは起きないと判断できた。ただ、index.tsからのエクスポートは削除し、tsconfigのexcludeに追加した。「残すけど使わない」状態を明確にした。

### 1a-2: npm → pnpm 移行

予想通り幽霊依存が大量に発覚した。最初`shamefully-hoist`なしで試したら数十個のエラー。`packages/frontend-shared`が`react`、`hono`、`@tanstack/react-query`など、ルートや他ワークスペースの依存に暗黙的に乗っかっていた。

計画に「shamefully-hoist=trueが必要になる場合は`.npmrc`に追加」と書いておいて正解だった。各package.jsonに不足分を追加する正攻法もあるが、一気にやると変更量が膨大になるし、この段階では既存コードを壊さないことが最優先。今後Phase 1b以降で新パッケージを追加する際に、依存関係を正しく宣言する習慣をつければいい。

hoistした後に残った2つのエラーが面白かった：
- `hono/jwt`の`verify`が3引数になっていた。pnpmがlockfileを新規生成したことで、honoが4.8.x→4.12.1に更新され、破壊的変更を踏んだ。npm時代のpackage-lock.jsonが古いバージョンを固定していたのが外れた形。`HS256`を第3引数に追加して解決
- `@testing-library/react`のReact 19対応が進んで`onCaughtError`が正式サポートされ、`@ts-expect-error`が不要になった。こちらは良い変更

Corepackでpnpmをセットアップしようとしたら、署名キーの不一致でエラーが出た。corepack 0.29.4が古すぎる。幸いpnpmがグローバルに入っていたので回避できたが、CIでは`pnpm/action-setup@v4`を使うことで解決している。ユーザーのローカル環境のcorepackは更新した方がいいが、今は動いているので触らなかった。

### ドキュメント更新の指摘

作業完了を報告したら、ユーザーから「CLAUDE.mdとかREADME.mdも更新いるんじゃない？」と指摘された。完全に見落としていた。`npm run`を`pnpm run`に変えるのは当然やるべきだし、mobile.mdへの参照削除もそう。Makefile、knowledgeドキュメント3つ（backend.md、frontend.md、database.md）も含めて全部更新した。

これは反省点。パッケージマネージャの移行は「コードの変更」だけでなく「ドキュメントの変更」もセットで考えるべきだった。特にCLAUDE.mdは自分自身が読む設定ファイルなのに、`npm run test-once`のまま残していたら、次のセッションで古いコマンドを実行してしまう可能性があった。ユーザーに指摘される前に気づくべきだった。
