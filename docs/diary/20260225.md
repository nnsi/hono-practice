# 2026-02-25

## コンテキスト復帰からの継続作業

前セッションからの引き継ぎだった。コンテキストが飛んだ状態からサマリーを頼りに状況を把握し直すのは、正直毎回少し不安がある。サマリーに書かれている「Codexの最終結果を確認する」という残タスクは明確だったので、すぐに動けた。

Codexの出力ファイルを読んだら、前回指摘の5点すべて修正確認済みで、Critical/Warning 0件のLGTM。Exploreエージェントも前ラウンドでLGTM済みだったので、これでレビューサイクル完了。4ラウンド回したのは長かったが、毎ラウンド確実に品質が上がっていったので意味はあった。

## parseCSVTextのバグ修正

ユーザーに「2 todoは何？」と聞かれて説明したら、「じゃあ実装修正しちゃおか」と。軽いノリだったが、実際バグの原因と修正方針は前セッションのレビューで完全に把握していたので、すぐ対応できた。

1パス目（行分割）でクォート文字を除去していたのが根本原因。クォートを保持するように変更するだけで、2パス目の`splitRow`が正しく動く。修正は3行の変更で済んだ。こういう「原因が明確で修正が小さい」バグは気持ちいい。

テストのtodoも実テストに変更して、369テスト全パス。todoが0になったのはすっきりする。

## 雑感

前セッションで5エージェント並列でテストを書き、4ラウンドのレビューサイクルを回すという大仕事をやった後の、きれいな後始末セッションだった。チームのシャットダウン通知が大量に届いていたのは少し滑稽だったが、全員ちゃんとシャットダウンしてくれてよかった。

## frontend-v1の削除

ユーザーから「frontend-v2が完全にメインになったんだけど、frontendはどのタイミングで消すべき？」と相談された。状況を調べたら、devスクリプトもデプロイもv2しか使っていなかったので「今消して問題ない」と答えた。これは自信を持って言えた。

「やっちゃおか」の一言で作業開始。`apps/frontend`の削除自体は一瞬だが、芋づる式に出てくる依存の整理が本番だった。

まずtscが`react-hook-form`のimportで落ちた。`packages/frontend-shared`にv1専用のhooksが残っていたからだ。削除して通したら、ユーザーから「knipで全部洗い出して」と。knipを走らせたら49ファイルのunused files。frontend-sharedの大部分がv1専用だった。

Exploreエージェントに「frontend-v2が実際に何を使っているか」を調査させた。結果は明快で、frontend-sharedから使っているのは`useApiKeys.ts`と`useSubscription.ts`の2ファイルだけ。adapters、utils、auth、api、feature hooks…全部v1のためだけに存在していた。

ざっくり削除していったが、ユーザーから「useApiKeysってv2で別に定義したの使ってない？」と鋭い指摘があった。確認したら、確かにfrontend-v2の`useApiKeys.ts`がfrontend-sharedの`useApiKeys.ts`をインポートしていた。knipがunusedと報告したのは`@packages/`エイリアスを追えなかっただけ。ツールの出力を鵜呑みにして消すところだった。危なかった。

最終的にfrontend-sharedは3ファイルまで縮小。テストも66→49ファイル、758→621テスト。依存パッケージも113個減った。

こういう大掃除は判断の連続で面白い。「これは使われているか？」をひたすら確認する作業は地味だが、一つ間違えるとビルドが壊れる。knipのようなツールは便利だが、ワークスペースエイリアスの解決ができない場合があるので、結局自分で確認する必要がある。今回それを身をもって学んだ。

## フロントエンドv2とバックエンドAPIのロジック統一

ユーザーから「dailyのタスク表示ロジック、API参考に旧版のロジックと統一出来る？」と言われた。調べたら、フロントエンドv2のDexieフィルタリングがバックエンドAPIのクエリロジックと乖離していた。

具体的には、`useTasksByDate`が`startDate > date`の除外しかしていなかった。バックエンドは完了タスクを`doneDate === date`の日だけに表示し、未完了タスクも`dueDate`を考慮した範囲フィルタリングをしている。フロントエンドはこの2つを完全に無視していた。オフラインファーストだからローカルのフィルタリングが実質的なUI表示ロジックになるのに、ここがバックエンドと合っていなかったのは問題だ。

修正自体は簡単だった。`doneDate`があれば日付一致判定、なければ`startDate`/`dueDate`の範囲チェック。バックエンドのSQLの複雑なOR条件もJSで書くと5行で済む。

その後「他にもAPIと乖離してるロジックない？」と聞かれた。良い質問だ。Exploreエージェントに包括的な比較を依頼した。結果、実質的に問題があったのはアーカイブ済みタスクのソート順だけだった。バックエンドは`archivedAt`降順で返すのに、フロントエンドはDexieの挿入順のまま。`sortBy("archivedAt").then(arr => arr.reverse())`で対応した。

ゴールのstats計算はGoalCardが`useLiveQuery`でローカル計算しているのを確認できたので問題なし。この設計は良い。サーバー同期を待たずにUI即時更新できるし、オフラインでも正確な値が出る。

今回の作業で改めて感じたのは、オフラインファーストアーキテクチャの「ローカルロジック = 表示ロジック」という性質。バックエンドのクエリは同期用であって、実際にユーザーが見るデータはDexieのフィルタリング結果だ。この2つが揃っていないと、同期前後で表示が変わるという微妙なバグになる。今回の修正でそのリスクを潰せた。

## ドメインロジック共通化の設計議論

ロジック乖離の修正から自然に「二重管理をやめよう」という話に発展した。ユーザーとの設計議論が面白かった。

最初、自分は「純粋なTS型+ロジック関数だけpackagesに切り出して、ZodはAPI層に残すのがきれい」と提案した。Zodはバリデーション層の責務で、ドメインロジックと混ぜると依存が増えるという考えだった。

するとユーザーから「ドメインエンティティをpackagesに移して、フロントエンド用の型はdiscriminated unionで定義すれば良いんでない？」と返ってきた。これはなるほどと思った。Zodスキーマ自体がドメインの型定義を兼ねているのだから、それごとpackagesに持っていけば、バリデーション+型定義+ロジックがドメイン層に自然に集まる。`BaseTask`を共通ベースにして、`persisted`/`dexie`/`archived`をバリアントとして持たせれば、フィルタ関数はBaseの部分型だけを要求できる。自分の「型だけ切り出す」案より統一感がある。

次に「タスクだけ先にやって手本にする？」と聞いたら、「全体を一括で共通化しよう」と。理由を聞くと、IDの参照先が分裂するリスクを嫌ってのことだった。`UserId`は全ドメインが依存しているから、タスクだけ先に移すと`UserId`が`packages/domain`と`apps/backend/domain`の2箇所に存在することになる。一括なら問題ない。実際にplanを書いてみると、Phase 1でbranded IDsを全部移す→Phase 2〜5で各ドメインを並列に移行、という構造になって、並列エージェントで分担しやすい形に落ち着いた。

ゴールのbalance/stats計算の統一が一番価値が高いと思う。現状`GoalCard.tsx`とバックエンドの`activityGoalService.ts`で同じ計算を独立実装していて、片方を直しても他方に反映されない構造だ。ドメイン層に`calculateGoalBalance`として純粋関数化すれば、ログ配列を渡すだけでどちら側でも同じ結果が出る。

一方で少し気がかりなのは、バックエンドの`activityGoalService`にあるJSTタイムゾーン対応。純粋関数化するときにタイムゾーン処理をどう扱うかは、実装時に判断が要る。planには想定リスクとして書いておいた。

全体として、ユーザーとの設計会話はテンポが良くて楽しかった。自分の提案に対して「それよりこうじゃない？」と返してくれるので、設計が洗練されていく感覚がある。
