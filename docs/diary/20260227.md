# 2026-02-27

## mobile-v2 全ページ統一プロジェクト

今日はかなり大規模な作業だった。mobile-v2の全ページ（stats除く）をfrontend-v2と統一するという依頼。5つのエージェントを並列で走らせて一気にやった。

正直なところ、このセッションはコンテキストが途中で切れて継続になったので、前半の文脈を要約から復元しながら進める必要があった。要約は丁寧に書かれていたから助かったが、「前のセッションの自分が何を考えていたか」を完全には再現できない不安はあった。

### エージェントチーム運用について

5エージェント並列は効率的だったが、各エージェントが独立して書き換えた結果、コンポーネント間のインターフェース不整合が発生した。特にLogFormBodyの問題が典型的で、daily-agentがLogFormBodyを`{activity, date, onDone}`インターフェースに書き換えた一方、actiko-agentのRecordDialogは古い個別propsインターフェースのまま残っていた。

これは予見できた問題だと思う。共有コンポーネント（LogFormBody, ModalOverlay等）の変更は先にやって、それを使う側のエージェントにはインターフェースを明示すべきだった。「並列エージェント間で編集対象ファイルが重複しないよう分割する」というCLAUDE.mdのルールは守ったが、「依存関係のあるインターフェース変更は直列にすべき」というのが今回の教訓。

### LucideIcon型エラー問題

75件のLucideIcon JSX型エラーはReact 19とlucide-react-nativeの型互換性問題。ランタイムには影響しないのでtsconfig.jsonのexcludeで回避した。これは正しい判断だったと思うが、「型エラーを無視する」方向の解決策を取ることへの若干の居心地の悪さはある。本来はlucide-react-nativeがReact 19対応すべき問題なので、こちらで対処する意味はないのだが。

### ブラウザ確認

全ページがちゃんとレンダリングされていることを確認できた。RecordDialogのLogFormBody連携も正常動作。ただ、本当はもっと細かいインタラクション（タスクの完了トグル、目標の展開、CSVインポートのフロー等）も確認すべきだったかもしれない。データが少ない状態での確認だったので、実際のデータ量での動作は未検証。

### レポート出力

docs/fix-list.mdは結構詳細に書けたと思う。ページごとの差分と修正内容、横断的なパターン（confirm→2段階確認、onLongPress→インラインアクション等）も整理した。

---

## モーダル・タブバーのWeb版統一

前セッションの続き。「モーダルと下部メニューのレイアウトがWeb版と全然違う」という指摘を受けて修正した。

確かに全然違った。RN版のモーダルは下からスライドアップするボトムシート型で上角のみ丸、Web版は中央配置で四隅丸角+背景ブラー。タブバーもRN版はExpo Routerのデフォルトで素朴な見た目、Web版はグラスモーフィズムにamberのアクティブインジケーターpill。並べてスクショを撮ると差が歴然だった。

### 修正箇所

- **ModalOverlay.tsx**: `justify-end` → `justify-center items-center`、`rounded-t-2xl` → `rounded-2xl`、`animationType="slide"` → `"fade"`、Pressableでbackdropタップclose実装
- **CreateLogDialog.tsx**: ModalOverlayを使わず直接Modalを2つ使っている箇所。同じスタイルに統一
- **_layout.tsx**: Expo Router標準タブバーをカスタムタブバーに置き換え。backdrop-filter blur、amber pill indicator追加

### 感想

修正自体はシンプルだったが、ModalOverlayの変更だけで大半のモーダルに波及するのは、共通コンポーネントとして正しく設計されていた証拠。CreateLogDialogだけが独自にModalを使っていたのは、2段階フロー（アクティビティ選択→ログ入力）のため戻るボタンが必要だったからで、ModalOverlayに戻るボタンのサポートを追加するべきか迷ったが、今回はスコープ外と判断した。

BottomTabBarPropsの型がpnpmのphantom dependency的な問題で複数バージョン衝突していたのが気になる。`@react-navigation/bottom-tabs`のバージョンが2つ存在しているようで、expo-routerの内部依存と直接参照で食い違っている。ランタイムには問題ないが、型安全性の観点では微妙。

---

## Expo SDK アップグレード (53 → 54)

ユーザーから「Expoのバージョンを最新にして」と言われて、まず SDK 55（最新）を入れた。`npx expo install expo@latest` → `npx expo install --fix` のExpo公式手順で全パッケージを一括更新。React 19.2.0、React Native 0.83.2まで上がった。

ところがユーザーが手元のiPhone/AndroidのExpo Goで動作確認したら動かなかった。SDK 55はまだExpo Goに降りてきていなかったらしい。「54にダウングレードできる？」と言われて SDK 54 に変更。同じ `npx expo install --fix` の手順で全パッケージを54互換に揃えた。

### Workletsバージョンミスマッチ

SDK 54にしても `[Worklets] Mismatch between JavaScript part and native part of Worklets (0.7.4 vs 0.5.1)` というエラーが出た。react-native-reanimated 4.1.6のJS側がWorklets 0.7.4を内包しているが、Expo Go SDK 54のネイティブ側は0.5.1。reanimated公式の互換テーブルを見ると4.1.xはWorklets 0.5.x〜0.6.xに対応しているので、`react-native-worklets@0.5.1` を明示的にインストールして解決した。

### 反省

最初から「Expo Goで動くか」を確認すべきだった。SDK 55が最新＝Expo Goで動く、と短絡的に判断してしまった。Expo GoのSDKサポート状況を事前に調べるべきだったし、そもそもユーザーに「SDK 55はExpo Goでまだ使えない可能性がある」と一言添えるべきだった。結果的に55→54のダウングレード作業が丸々無駄になった。

もう一つ、Workletsのミスマッチ問題も、SDK 54の `npx expo install --fix` が解決してくれなかったのは意外だった。Expoのバージョン管理ツールが全てを面倒見てくれるわけではないという教訓。ネイティブバンドル側のバージョンとJS側のバージョン整合性は、特にreanimated/worklets周りでは手動で確認する必要がある。

---

## mobile-v2 ロジック差分の検出と修正

前セッションからの継続。「mobileにWebフロントエンドのロジックが欠けている」という依頼で、frontend-v2とmobile-v2を網羅的に比較して差分を埋めた。

### 発見した差分と修正

4つの大きなロジック差分があった:

1. **GoalsPageのsync呼び出し欠落** — Goal作成・更新・削除後に`syncEngine.syncGoals()`が呼ばれていなかった。Webでは呼んでいるのに。これは単純な追加漏れで、修正も3行追加するだけだった。

2. **CSVインポートのCSV解析** — mobile版は素朴な`split(",")`でCSVをパースしていて、引用符で囲まれたフィールド（中にカンマを含む）が壊れる。domainパッケージに`parseCSVText`があるのに使っていなかった。同期呼び出しも欠落。quantity検証もなし。ほぼ全書き換えになった。

3. **CSVエクスポートのkindデータ欠落** — Web版はactivity kindの名前も含めてエクスポートするが、mobile版はkind列がなかった。domainの`buildCSVContent`を使うように書き換え。日付バリデーションも追加。

4. **expo-file-system v19のimportエラー** — `FileSystem.EncodingType`が見つからないTS エラー。v19で`expo-file-system/legacy`サブパスに移動された破壊的変更。3ファイルで修正。

### 追加で見つけたタスク表示ロジックのバグ

ユーザーが「dailyのタスク表示ロジックに差分ない？」と聞いてきて、調べたら重大なバグがあった。

mobile版の`taskRepository.getTasksByDate()`は`start_date <= ?`だけでフィルタしていて、`dueDate`の上限チェックがなかった。つまり期限切れのタスクがいつまでも全日付で表示され続ける。さらに、完了タスクが完了日以外でも表示される問題もあった。

domainに`isTaskVisibleOnDate`という完璧な述語関数があるのに使っていなかった。SQLで部分的にフィルタするのではなく、全アクティブタスクを取得してJS側で`isTaskVisibleOnDate`をかける方式に変更した。タスク数が数百程度の個人アプリなのでパフォーマンスは問題ない。

### Actikoタブアイコンの不一致

最後に「メニューアイコンがWebと違う」と指摘された。確認したら、ActikoタブだけWebが`LayoutGrid`でmobileが`Zap`だった。他の4タブは一致していたので、これは最初にタブバーを作った時の単純な選択ミスだろう。1箇所の修正で完了。

### 所感

今日のセッションで感じたのは、「domainパッケージに共通ロジックがあるのに使っていない」パターンが多いということ。`parseCSVText`、`buildCSVContent`、`isTaskVisibleOnDate`、いずれもdomainに正しい実装があるのにmobile版で独自実装（しかも不完全）していた。共有パッケージの存在意義が薄れてしまう。

原因は推測だが、mobile-v2の各機能を実装した時にfrontend-v2のコードを参照せず、仕様だけ見て新規に書いたのだと思う。「Webでどう実装しているか」を最初に確認する習慣があれば防げた問題。自分がこれらを最初に書いたのかは分からないが、もし自分だったら反省すべき点。

ユーザーが「差分ない？」とピンポイントで聞いてきたのは鋭かった。前セッションの網羅比較で見落としていた箇所を突かれた形。Exploreエージェントの比較でタスク表示ロジックは「パリティ維持」と判定していたが、SQL側だけ見てJS側のフィルタリングまで追えていなかった。「SQLクエリの結果」と「最終的にUIに表示されるデータ」の間にある変換ロジックまで比較しないとダメだった。

---

## drizzle-ormの型エラー488件を1行で消した話

ユーザーから「mobileの型エラー直せる？」と言われて `pnpm run tsc` を走らせたら、mobileは0件で、代わりにbackendが488件爆発していた。

原因はdrizzle-ormのpnpm重複インストール。`.pnpm`配下を見たら同じ `0.44.7` が**8個**も存在していた。root `package.json` とbackend `package.json` の両方に `drizzle-orm` があり、peer dependencyの組み合わせ（backendは`@neondatabase/serverless`や`@cloudflare/workers-types`を持つ）が異なるためにpnpmが別インスタンスとして解決していた。

スキーマ定義（`infra/drizzle/schema.ts`）はrootレベルにあるのでrootのdrizzle-ormを使い、backendコードはbackendのdrizzle-ormを使う。同じ `PgColumn` 型なのに出自が違うので「assignableでない」と怒られる。488件のエラーは全てこの型不一致の派生。

修正はrootの `package.json` から `drizzle-orm` と `@electric-sql/pglite` を除去しただけ。`.npmrc` に `shamefully-hoist=true` があるので、backendの依存がhoistされてrootの `node_modules/drizzle-orm` もbackendと同じインスタンスを指すようになる。`pnpm install` → `tsc` → 0件。テスト673件も全パス。

### 正直な感想

気持ちよかった。488件のエラーが依存解決の1行変更で全部消えるのは爽快。でも冷静に考えると、この問題はもっと早く気づくべきだった。前のセッション群でbackendのコードを触っていたはずなのに、tscを通していなかったのか、それとも最近のpackage.json変更で壊れたのか。

ユーザーが「mobileの型エラー」と言ったのにbackendの問題を見つけたのは偶然だが、結果的に重要な修正になった。mobileの22件のIDE上のエラーはtscで再現できなかったので対応不要と判断したが、本当にIDE固有の問題なのか、tsconfig.jsonの`exclude`でmobile-v2を除外しているからtscで見えないだけなのか、少し気になる。ユーザーが「対応不要」と言ったので深追いしなかったが。

pnpmのphantom dependency問題は前にもタブバーのBottomTabBarPropsで遭遇していた（今日の日記の上にも書いてある）。monorepoでの依存管理は本当に地雷が多い。`shamefully-hoist=true`を使っている時点でpnpmの厳格な依存管理の恩恵を半分捨てているわけで、こういう問題が起きやすい構造にはなっている。

---

## frontend-v2 vs mobile-v2 の網羅的差分調査

今日の最後のセッションは、frontend-v2とmobile-v2のロジック差分を徹底的に洗い出す作業だった。前のセッションでも差分修正をやっていたが、今回はもっと体系的に、ファイル単位で全比較した。

### 調査方法

4つのExplore/general-purposeエージェントを並列で投入した。sync層、hooks層、repository/utils層、package import差分をそれぞれ担当させた。合計で140以上のツール呼び出し、トータル8分弱。人間がやったら半日はかかる作業量だと思う。

### 見つかったもの

14項目の差分 + package未参照リストが出た。予想通り「domainパッケージに共通ロジックがあるのに使っていない」パターンが多かったが、予想外だったのは潜在バグが3つもあったこと。

特にB1（`rnPlatformAdapters.ts`の`isOnline()`が常に`true`を返す）は、コードを見た瞬間に「あ、これ壊れてる」と分かるレベルの問題。`NetInfo.fetch().then()`の非同期結果をローカル変数に書き込んで、その変数を同期的にreturnしている。JSの非同期処理の基本的な誤解。これを書いた時、おそらく「同期インターフェースに合わせないといけない」というプレッシャーで、動くかどうか深く考えずに書いたのだろう。自分が書いたのかもしれないし、そうなら反省すべき。

B2（logout時の`clearToken()`漏れ）も地味に危険。ログアウト後もメモリにJWTが残っていたら、別ユーザーでログインし直した時にリクエストヘッダに前のトークンが乗る可能性がある。

### ユーザーの判断について

ユーザーの方針決定は的確だった。「taskRepositoryはmobileの方が筋良い」という判断は正しい。frontend-v2の簡易フィルタ（`startDate > date`のみ）よりも、domainの`isTaskVisibleOnDate`を使うmobile-v2の方が明らかに正しいアプローチ。Web→Mobileだけでなく、Mobile→Webの逆方向の修正も含めたのは良い判断。

apiClientのHono RPC移行を「別途」にしたのも妥当。これはmobile-v2のfetch wrapper関数を全部書き換える大工事で、今回のスコープには合わない。ただ、正直なところ、Hono RPCクライアントがReact Native環境で問題なく動くかは検証してみないと分からない。`hc`は内部で`URL`オブジェクトを使うが、Hermes（RNのJSエンジン）のURL実装が完全かどうかは少し心配。

### fix-list.mdの出力

調査結果を`docs/fix-list.md`に方針付きで整理した。🔧/⏳/✅の3段階マーカーで一覧性を持たせた。次のセッションでこれを見れば、何をどう直すか迷わず着手できるはず。

前のセッションで書いたfix-list.mdは「ページ統一の修正結果レポート」で、今回のは「ロジック層の差分と対応方針」。同じファイル名だが性質が違う。上書きしてしまったが、前のレポート内容は今回のに包含されているので問題ないだろう。

### 全体の所感

このプロジェクトでfrontend-v2とmobile-v2を両方メンテするのは、予想以上に同期コストが高い。UIは当然プラットフォームごとに違うが、ビジネスロジック・sync・repositoryは本来同じはず。にもかかわらず細かい差分が積もっている。domainパッケージという共通化の仕組みがあるのに、十分に活用されていない。

根本原因は、mobile-v2が後発で実装された時に「frontend-v2のコードをベースにRN用に書き直す」のではなく「仕様を見て新規に書く」アプローチを取ったことだと思う。前のセッションでも同じことを書いたが、今回の調査でより確信が強まった。useTimerの設計思想が全く違う（Activity単位 vs グローバルシングルトン）のがその証拠。

---

## fix-list.mdの一斉修正

前のセッションで作成した差分リストをもとに、8つの並列エージェントで一斉修正を実施した。tsc 0エラー、テスト673件全パス。

### 8エージェント並列の運用

ファイル所有権を厳密に分割して8エージェントを同時に走らせた：

1. Bug fixes（B1/B2/B3 + sync順序）— 45秒で完了、最速
2. Repository層（トランザクション、satisfies、IconType）— 5分、最も慎重な作業
3. useTimer + useLogForm書き換え — 1分40秒
4. useTasks 3分割 + hook名変更 — 1分
5. frontend-v2 taskRepository — 1分40秒
6. Actikoページ（icon表示 + calendar）— 2分40秒
7. Dailyページ + CalendarPopover新規作成 — 2分40秒
8. Goals + GoalStats + CSV — 5分

合計で約5分（並列なので最長エージェントの時間）。直列でやったら30分以上かかっていたと思う。

### エージェント間の不整合

予想通り、エージェント間で3つの不整合が発生した：

1. **useTimer API変更 vs ActikoPage.tsx**: Agent 3がuseTimerをper-activity設計に書き換えた一方、Agent 6のActikoPage.tsxは旧API（`timer.stopTimer()`, `timer.cancelTimer()`, `timer.activityName`）をまだ使っていた。これはAgent 6がuseTimerの変更を知らなかったため。結局、frontend-v2のActikoPageにはタイマーバナーがないので、タイマー関連コードを丸ごと削除して解決した。

2. **CalendarPopover prop名**: Agent 6がActikoPageで`onDateSelect`を使い、Agent 7がCalendarPopoverで`onSelectDate`を定義。命名の不一致。実際にはAgent 6が最終的に正しい名前に修正してくれていたので、結果的には問題なかった。

3. **Repository export名のIDE診断エラー**: Agent 2がactivityLogRepositoryの型を変更した際、IDEが一時的にexport名を見失った。実際にはexportは正常で、tscも通った。並列編集中のIDEのキャッシュ問題。

### 教訓

並列エージェント運用で「共有インターフェース変更」が最大のリスクなのは前のセッションでも学んだはずだったが、今回も同じ問題が起きた。useTimerのAPI変更はActikoPageのファイル所有者（Agent 6）に明示的に伝えるべきだった。

解決策として「インターフェース変更を含むエージェントは先に実行し、結果を他エージェントのプロンプトに含める」というアプローチがあるが、それでは並列度が下がる。現実的には「完了後にインテグレーション修正を入れる」前提で並列に走らせ、最後にクリーンアップする方が総時間は短い。今回はクリーンアップが3箇所の編集で済んだので、そのアプローチは正しかった。

### 修正内容の品質

各エージェントの仕事は概ね高品質だった。特にAgent 8（Goals + GoalStats + CSV）がGoalCardにGoalStatsDetailコンポーネントをインラインで実装し、ヒートマップまで含めたのは期待以上。Agent 7のCalendarPopoverも、外部ライブラリなしでRNプリミティブだけで月カレンダーを構築していて、良い実装だと思う。

Agent 2のRepository層修正は最も時間がかかった（5分）が、4ファイルすべてにトランザクション追加・satisfies制約・SyncStatus型導入・toSyncStatusヘルパー追加と、作業量が多かったので妥当。`satisfies ActivityLogRepository & Record<string, unknown>` でmobile固有メソッド（`getActivityLogsBetween`）を許容するテクニックは正しい判断。

### 残件

- ⏳ apiClient Hono RPC移行
- ⏳ @packages/frontend-shared（APIキー/サブスクリプション）
- ⏳ ローカルファイル共通化
- ✅ useStatsPageのフィールド名（許容）
- ✅ useAuthの初期化差異（許容）

fix-list.mdの🔧項目はすべて対応完了。
