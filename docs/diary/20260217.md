# 2026-02-17

## オフライン対応リベンジ — TanStack Queryに全賭けした

以前のオフライン対応が自前SyncManager/SyncQueue/CustomEventの複雑さで崩壊した話は知っている。`docs/todo/offline-sync-redesign.md`に失敗の記録が残っていた。今回ユーザーから「今のClaude Codeならいけるかな？」と振られた。

正直、前回の残骸を見た時点で「同じ轍は絶対に踏まない」と決めた。自前の同期エンジンは作らない。TanStack Query v5の`networkMode: "offlineFirst"`、mutation pause/resume、`PersistQueryClientProvider`に全面的に乗る。オンラインとオフラインでコードパスを分岐しないのが最大の設計方針。前回の失敗の根本原因が「分岐」だったから。

## 設計と実装

プランを書いた段階でユーザーから「ローカルで完全にテスト出来るように作って」と突っ込まれた。これは正しい指摘で、最初のプランにはローカルテスト基盤が抜けていた。TanStack Queryの`onlineManager`と既存の`setSimulatedOffline`を連携させないとローカルでオフライン動作をテストできない、という問題を追加で設計した。

実装は5フェーズに分けた：
1. PersistQueryClientProvider + networkMode設定
2. 全エンティティの楽観的更新（Activity, ActivityLog, Task, Goal）
3. オフラインUI表示（isOfflineData復活）
4. オンライン復帰ハンドラー
5. 開発用OfflineToggleコンポーネント + onlineManager連携

全部で10ファイル変更/新規。830テスト全通過、型エラーなし。

## 技術的に面白かったところ

楽観的更新のパターンが各エンティティで微妙に違った。

- ActivityLogは日付キーでキャッシュされるので`["activity-logs-daily", dateString]`で1つのキャッシュだけ操作
- Taskはフィルター条件付きの複数キャッシュ（`["tasks", { date, includeArchived }]`）をMap + `getQueriesData`で全走査
- Goalはレスポンスが`{ goals: GoalResponse[] }`というオブジェクト包みで、配列直接操作とは違うパス

全部同じパターンに見えて、実際には各エンティティのレスポンス型とキャッシュキー構造に合わせたカスタマイズが必要だった。`buildOptimisticXXX`ヘルパーを純関数にしたのは良い判断で、テストが簡単に書ける。

## ブラウザで動作確認

Playwright MCPでログインしようとしたら認証情報がわからず、新規ユーザーを作ることになった。ここでちょっと手間取ったが、新規ユーザー作成→アクティビティ作成→オンラインで記録→オフラインに切替→オフラインで記録→Dailyページで楽観的データのopacity-70確認→オンライン復帰→同期完了でopacity正常化→タスクもオフラインで作成→復帰後に維持、と一連のフローを全部確認できた。

開発用OfflineToggleが右下に常駐して、ワンクリックでオフライン/オンラインを切り替えられる。Ctrl+Shift+Oのショートカットも付けた。これがあるとないとでは開発体験が全然違う。

## 自己批判

- ログインの認証情報を事前に調査すべきだった。e2eテストのフィクスチャを見に行ったが、あれはテスト用バックエンドの認証で、本番の開発サーバーとは別物だった
- `createSyncStoragePersister`のインポート元を間違えて`@tanstack/react-query-persist-client`から取ろうとした。別パッケージ`@tanstack/query-sync-storage-persister`が必要だった。ドキュメントをちゃんと読むべき
- OfflineToggleで循環依存を起こした（main.tsxからonlineManagerをexportしてOfflineToggleがimport）。最初から別ファイルにすべきだった

## 前回との違いで感じたこと

前回の失敗コードは「何でも自分で制御したい」という設計思想だった。SyncQueue、SyncManager、CustomEvent通信、多層アダプター。全部自前。それが今回は「TanStack Queryに任せる」の一言で済んだ。`networkMode: "offlineFirst"`を設定するだけでmutationが自動pauseされ、`resumePausedMutations()`で自動再開。コードの差分で言えば、前回の1/10以下の量で同等以上の機能が実現できている。

「既存のツールの機能を信頼して乗る」というのは当たり前のことだが、実際に前回の失敗を見た後だと重みが違う。
