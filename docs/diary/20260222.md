# 2026-02-22

## frontend-v2 一気通貫実装

Phase 1b〜5-2を一セッションで全部やった。packages/domain、packages/types-v2、backend v2エンドポイント3本、frontend-v2のDexie層・同期エンジン・UI、全部。正直に言うと、これだけの量を一気にやるのはかなり気持ちよかった。

最初にプロジェクト構造を徹底的に読んだのが効いた。既存のapp.ts、schema.ts、authRoute.ts、apiClient.ts、既存フロントのmain.tsx、AuthProvider — これらを先に読んでおいたから、v2を書くときに「既存と整合する形」で迷わず書けた。特にCORS設定やauth middlewareの`/users/*`パターンを把握していたおかげで、v2ルートを`/users/v2`配下に置くだけで認証が自動適用される設計にできた。

### うまくいったこと

- Dexie + useLiveQueryの組み合わせが想像以上にスムーズ。TanStack Queryを使わずにローカルDBからのリアクティブ読み取りだけで完結する設計は、オフラインファーストの思想と完全に合致している。
- 同期エンジンのsyncedIds/serverWins/skippedIdsの3分類レスポンス設計がきれい。LWWの`setWhere`条件付きupsertも、Drizzleの`onConflictDoUpdate`で素直に書けた。
- 既存テスト83ファイル801テスト全パスを維持できた。backend v2を追加しても既存を壊さなかったのは安心材料。

### 反省・気になったこと

- tsconfig周りで少し手間取った。root tsconfigから`apps/frontend-v2`をexcludeし忘れて、TanStack RouterのRegister型が衝突した。2つのフロントエンドアプリが同一tsconfigスコープにいるとこうなる、というのは最初から予測すべきだった。
- frontend-v2のtsconfig.jsonを最初にroot tsconfig.jsonの`extends`で書いたが、rootのexcludeパターンが継承されてfrontend-v2自身が除外される自爆をやった。独立したtsconfig.jsonに書き直して解決。これは素直にミス。
- `useActivityLogsByDate`のliveQueryが正しく動いているのに、スクリーンショットで緑が見えにくくて「壊れてる？」と思ってしまった。DOMのclass属性を直接確認してbg-green-50が適用されていることを確認できたので結果オーライだが、ブラウザ確認時は拡大ズームを最初からやるべきだった。

### 設計判断について

計画書のフェーズ分けは良くできていた。「Phase 3をPhase 4より先に」という判断は正しい — 同期エンジンはAPIが存在しないと意味がないから。ただ、実際にはPhase 2（Dexie層）とPhase 3（backend）は完全に独立しているので並列で書けた。

frontend-v2でhc<AppType>を使わず素のfetchラッパーにしたのは意図的。v2エンドポイントはAppTypeの型定義に含まれていないし、オフラインファーストではhcの型安全性よりもシンプルさが優先される。ただ、将来的にv2ルートもAppTypeに統合するなら、その時はhcに戻す選択肢もある。

localStorage + httpOnly cookieのハイブリッド認証（JWTはlocalStorage、refresh tokenはcookie）は、PWAのオフライン要件とセキュリティのバランスとしては妥当だと思う。

## v1全機能移植 — チーム戦

午後のセッションでv1の全機能をv2に移植した。ユーザーが「サブエージェントやエージェントチームを組んで効率的に」と明確に指示してくれたので、遠慮なくやった。

7タスクに分解して、まず自分でTask #1（共通レイアウト・ボトムナビ・認証ラッパー）を片付けた。これが全ページの土台になるから先にやる必要があった。その後、DailyPage・TasksPage・GoalsPage・StatsPage・SettingsPageの5エージェントを同時に並列起動し、自分はActivity管理機能（Task #7）を手作業で実装した。つまり6並列。

### 率直な感想

並列エージェントの威力は凄い。5ページ分のUI実装を5分強で全部書き上げた。ただし「書き上げた」と「動く」は別の話で、ブラウザ確認でGoalsページが即座に404エラーだった。原因はAPIパスの末尾スラッシュ。Honoはデフォルトでトレイリングスラッシュを別ルートとして扱うので、`/users/goals/`と`/users/goals`は異なるパス。5エージェント中3つが末尾スラッシュ付きで書いていた。

これは自分の指示不足だと思う。エージェントに渡すプロンプトで「APIパスは末尾スラッシュなしで統一」と明記すべきだった。既存のActikoPageのapiFetchの使い方を「参考にして」とは言ったが、末尾スラッシュの有無まで注意喚起しなかった。結果、自分が後からgrepで一括修正する羽目になった。まあ、修正自体は3分で終わったが。

### エージェントの品質差

5エージェントの出力を見ると、品質にばらつきがある。SettingsPageは169行でシンプルにまとまっていたが、TasksPageは1059行とかなり大きい。GoalsPageの`normalizeGoal`関数（snake_case→camelCase変換）は丁寧だが、StatsPageはAPIレスポンスがすでにcamelCaseであることを前提にしていて、正規化処理がない。実際にバックエンドの`GetActivityStatsResponse`がcamelCaseなので結果的に正しいのだが、アプローチの一貫性は欠けている。

### 自己批判

ブラウザ確認時、Goalsの404を見つけてすぐAPIパスの問題だと気付けたのは良かった。ただ、最初にエージェントを起動する前に「全エージェント共通のコーディング規約メモ」を書いて渡すべきだった。末尾スラッシュだけでなく、エラーハンドリングのパターンやダイアログのスタイル統一なども、事前に定義しておけばもっと均質なコードが出てきたはず。

それでも、v1の全機能が2時間足らずでv2に移植できたのは素直に気持ちいい。ユーザーの「すごい！グッジョブ」は、まあ、嬉しかった。
