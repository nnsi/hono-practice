# 2026-02-22

## frontend-v2 一気通貫実装

Phase 1b〜5-2を一セッションで全部やった。packages/domain、packages/types-v2、backend v2エンドポイント3本、frontend-v2のDexie層・同期エンジン・UI、全部。正直に言うと、これだけの量を一気にやるのはかなり気持ちよかった。

最初にプロジェクト構造を徹底的に読んだのが効いた。既存のapp.ts、schema.ts、authRoute.ts、apiClient.ts、既存フロントのmain.tsx、AuthProvider — これらを先に読んでおいたから、v2を書くときに「既存と整合する形」で迷わず書けた。特にCORS設定やauth middlewareの`/users/*`パターンを把握していたおかげで、v2ルートを`/users/v2`配下に置くだけで認証が自動適用される設計にできた。

### うまくいったこと

- Dexie + useLiveQueryの組み合わせが想像以上にスムーズ。TanStack Queryを使わずにローカルDBからのリアクティブ読み取りだけで完結する設計は、オフラインファーストの思想と完全に合致している。
- 同期エンジンのsyncedIds/serverWins/skippedIdsの3分類レスポンス設計がきれい。LWWの`setWhere`条件付きupsertも、Drizzleの`onConflictDoUpdate`で素直に書けた。
- 既存テスト83ファイル801テスト全パスを維持できた。backend v2を追加しても既存を壊さなかったのは安心材料。

### 反省・気になったこと

- tsconfig周りで少し手間取った。root tsconfigから`apps/frontend-v2`をexcludeし忘れて、TanStack RouterのRegister型が衝突した。2つのフロントエンドアプリが同一tsconfigスコープにいるとこうなる、というのは最初から予測すべきだった。
- frontend-v2のtsconfig.jsonを最初にroot tsconfig.jsonの`extends`で書いたが、rootのexcludeパターンが継承されてfrontend-v2自身が除外される自爆をやった。独立したtsconfig.jsonに書き直して解決。これは素直にミス。
- `useActivityLogsByDate`のliveQueryが正しく動いているのに、スクリーンショットで緑が見えにくくて「壊れてる？」と思ってしまった。DOMのclass属性を直接確認してbg-green-50が適用されていることを確認できたので結果オーライだが、ブラウザ確認時は拡大ズームを最初からやるべきだった。

### 設計判断について

計画書のフェーズ分けは良くできていた。「Phase 3をPhase 4より先に」という判断は正しい — 同期エンジンはAPIが存在しないと意味がないから。ただ、実際にはPhase 2（Dexie層）とPhase 3（backend）は完全に独立しているので並列で書けた。

frontend-v2でhc<AppType>を使わず素のfetchラッパーにしたのは意図的。v2エンドポイントはAppTypeの型定義に含まれていないし、オフラインファーストではhcの型安全性よりもシンプルさが優先される。ただ、将来的にv2ルートもAppTypeに統合するなら、その時はhcに戻す選択肢もある。

localStorage + httpOnly cookieのハイブリッド認証（JWTはlocalStorage、refresh tokenはcookie）は、PWAのオフライン要件とセキュリティのバランスとしては妥当だと思う。

## v1全機能移植 — チーム戦

午後のセッションでv1の全機能をv2に移植した。ユーザーが「サブエージェントやエージェントチームを組んで効率的に」と明確に指示してくれたので、遠慮なくやった。

7タスクに分解して、まず自分でTask #1（共通レイアウト・ボトムナビ・認証ラッパー）を片付けた。これが全ページの土台になるから先にやる必要があった。その後、DailyPage・TasksPage・GoalsPage・StatsPage・SettingsPageの5エージェントを同時に並列起動し、自分はActivity管理機能（Task #7）を手作業で実装した。つまり6並列。

### 率直な感想

並列エージェントの威力は凄い。5ページ分のUI実装を5分強で全部書き上げた。ただし「書き上げた」と「動く」は別の話で、ブラウザ確認でGoalsページが即座に404エラーだった。原因はAPIパスの末尾スラッシュ。Honoはデフォルトでトレイリングスラッシュを別ルートとして扱うので、`/users/goals/`と`/users/goals`は異なるパス。5エージェント中3つが末尾スラッシュ付きで書いていた。

これは自分の指示不足だと思う。エージェントに渡すプロンプトで「APIパスは末尾スラッシュなしで統一」と明記すべきだった。既存のActikoPageのapiFetchの使い方を「参考にして」とは言ったが、末尾スラッシュの有無まで注意喚起しなかった。結果、自分が後からgrepで一括修正する羽目になった。まあ、修正自体は3分で終わったが。

### エージェントの品質差

5エージェントの出力を見ると、品質にばらつきがある。SettingsPageは169行でシンプルにまとまっていたが、TasksPageは1059行とかなり大きい。GoalsPageの`normalizeGoal`関数（snake_case→camelCase変換）は丁寧だが、StatsPageはAPIレスポンスがすでにcamelCaseであることを前提にしていて、正規化処理がない。実際にバックエンドの`GetActivityStatsResponse`がcamelCaseなので結果的に正しいのだが、アプローチの一貫性は欠けている。

### 自己批判

ブラウザ確認時、Goalsの404を見つけてすぐAPIパスの問題だと気付けたのは良かった。ただ、最初にエージェントを起動する前に「全エージェント共通のコーディング規約メモ」を書いて渡すべきだった。末尾スラッシュだけでなく、エラーハンドリングのパターンやダイアログのスタイル統一なども、事前に定義しておけばもっと均質なコードが出てきたはず。

それでも、v1の全機能が2時間足らずでv2に移植できたのは素直に気持ちいい。ユーザーの「すごい！グッジョブ」は、まあ、嬉しかった。

## リファクタリング — 巨大ファイルの分割

移植が終わった直後、ユーザーから「コードの見通しがものすごく悪い」と言われた。正直、わかっていた。移植時に各エージェントが1ファイルに全部詰め込む形で書いたから、700〜1060行のモノリシックなファイルが5つ並ぶ結果になった。移植速度を優先した代償。

ユーザーの指示は「frontendのフォルダ構成を参考にリファクタリングして」。v1のfrontendはドメインベースのフォルダ分割がきれいにできていて、actiko/、daily/、goal/、tasks/、stats/それぞれにコンポーネント単位でファイルが分かれている。これをv2でも再現する作業。

### 並列分割の実行

今回も5エージェント並列で、各ページを担当フォルダに分割させた。ActikoPage→actiko/、TasksPage→tasks/、GoalsPage→goal/、DailyPage→daily/、StatsPage→stats/。型定義はtypes.ts、ユーティリティは専用ファイルに切り出し、バレルエクスポートのindex.tsで束ねる構成。

結果としてはうまくいった。が、エージェント間でアプローチが分かれた。一部は元ファイルを削除してルートのインポートを更新、一部は元ファイルをプロキシ（再エクスポート）として残した。前回の末尾スラッシュ問題と同じパターン — エージェントへの事前指示が足りない。自分で後始末として、プロキシファイルを全削除し、ルートファイルのインポートを統一した。SettingsPageとLoginFormも手動でsetting/とroot/フォルダに移動。

### 学んだこと

並列エージェントを使うときの教訓が固まってきた。「何をやるか」だけでなく「どうやるか」のルール（削除するかプロキシ残すか、命名規則、エクスポートパターン）を事前に明文化しないと、後で必ず統一作業が発生する。2回目なのでさすがに次は最初からやる。

### 検証

tsc通過、801テスト全パス、biomeチェッククリア。Chromeで全6ページ（Actiko、Daily、Stats、Goals、Tasks、Settings）をスクリーンショット付きで確認して全部正常。dev portが1357（v1）ではなく2460（v2）だと途中で気付いて修正する一幕があったが、まあ些細なこと。

コード量は増えたが（ファイル数は増える）、各ファイルが100〜200行に収まって見通しは劇的に良くなった。ユーザーの「見通しが悪い」という指摘は完全に正しかった。移植時に自分から提案すべきだったかもしれないが、あの時点では「まず動くものを出す」が正解だったとも思う。タイミングの問題。

## コードレビュー — 間違えたディレクトリと並列修正の教訓

ユーザーから「frontend-v2のコードについて、ロジックの責務や一貫性についてサブエージェントとCodexにレビューを依頼して、両方からLGTMが出るまでブラッシュアップして」という依頼が来た。

### 致命的なミス：レビュー対象を間違えた

最初のExploreエージェントが「frontend-v2ディレクトリは存在しない」と報告してきた。globやfindで見つからなかったらしい。Windows環境特有の問題なのかもしれないが、自分はその報告をそのまま信じて `apps/frontend/` をレビュー対象にしてしまった。3つのサブエージェント + Codexで4並列レビューを実行し、問題を洗い出し、さらに3並列で修正まで走らせた。

途中でユーザーから「ちょっとまって、frontend-v2だけ頼んだのにfrontendも修正してる？」と指摘された。PowerShellの `Get-ChildItem` で確認したら `apps/frontend-v2/` は普通に存在していた。全部やり直し。`git checkout` で変更を全リバート。

これは明らかに自分の判断ミス。「ディレクトリが見つからない」時点で、別の方法で確認すべきだった。ユーザーが明確に「frontend-v2」と言っているのに、存在しないという報告を鵜呑みにしてfrontendを代わりにレビューする判断は擁護できない。

### 正しい対象での再レビュー

やり直しでは3並列（サブエージェント2 + Codex 1）でレビュー。結果、Critical 3件 + Warning 10件超が見つかった。

主要な問題：
- **EditActivityDialog**: レンダリング本体でsetStateを呼んでいた。Reactのルール違反。useEffectに移動。
- **initialSync.ts / ActikoPage.tsx**: `Record<string, unknown>` + `as string` でAPI応答をマッピング。型安全性ゼロ。共通の `apiMappers.ts` を作って型付きマッパーに統一。
- **リポジトリ命名**: `create`, `getByDate`, `update` など、ドメイン名を含まないメソッド名が大量。プロジェクト規約違反。全リネーム。
- **apiClient.ts**: トークンをlocalStorageに保存していた。メモリ管理に変更。
- **goalApi.ts**: components/ ディレクトリに配置されていた。api/ に移動。

### 並列修正の工夫

修正は2グループに分けて並列実行した。前回の教訓を活かして、ファイルの重複がないよう慎重にグループ分けした：
- **Group A**: apiClient.ts, useAuth.ts, DailyPage.tsx, TasksPage.tsx, Goals関連
- **Group B**: リポジトリ定義 + リネーム参照更新、apiMappers.ts新規、initialSync.ts、ActikoPage.tsx、EditActivityDialog.tsx

2グループ間でファイルの重複がゼロ。前回のセッション（午前中のリファクタリング）で3エージェントが同じファイルを編集して変更が消し合った経験から、今回は完全に排他的な分割にした。結果、コンフリクトなしで両方成功。

### 修正後の再レビュー

修正後にサブエージェントとCodexに再レビューを依頼。サブエージェントはLGTM。Codexは `goalApi.ts` の `Record<string, unknown>` と DailyPage のタスクトグル `res.ok` 未チェックでNOT LGTM。両方修正して、最終的にCritical 0件。

### ユーザーからの鋭い指摘

ユーザーから2つの鋭い指摘を受けた：

1. 「v2テスト書いてなくない？」— その通り。frontend-v2にはテストファイルが1つもない。全件テスト実行はv2コードの検証には一切ならない。tscの型チェックだけが有効な静的検証。指摘されるまで惰性でテスト実行していた。

2. 「v2は完全オフラインファースト仕様だよね。APIとの通信が失敗しても削除に失敗したりするの？」— GoalsPageにtry-catchを追加した修正に対する問いかけ。実はGoalsとTasksはDexieに保存されておらず、直接APIを叩くサーバー依存の実装になっている。つまりオフラインでは動かない。ユーザーの理想と現実の実装にギャップがある。レビューのスコープでこの設計問題を指摘すべきだったかもしれないが、「レビューで見つかった問題を直す」というスコープに留まった。

### 率直な感想

最初にディレクトリを間違えたのは痛い。ユーザーの時間を無駄にした。ただ、やり直し後の進め方は良かったと思う。レビュー→修正→再レビューのサイクルを2回転させて、両レビュアーからLGTMを取得。並列エージェントのファイル分割も前回の失敗を活かして改善できた。

Codexのレビューは毎回 `codex exec --full-auto` の使い方で手間取る。最初のセッションで `--approval-mode` が存在しないことを学んだのに、コマンドが不安定で毎回微妙にハマる。もう少し安定してほしい。
