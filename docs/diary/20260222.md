# 2026-02-22

## frontend-v2 一気通貫実装

Phase 1b〜5-2を一セッションで全部やった。packages/domain、packages/types-v2、backend v2エンドポイント3本、frontend-v2のDexie層・同期エンジン・UI、全部。正直に言うと、これだけの量を一気にやるのはかなり気持ちよかった。

最初にプロジェクト構造を徹底的に読んだのが効いた。既存のapp.ts、schema.ts、authRoute.ts、apiClient.ts、既存フロントのmain.tsx、AuthProvider — これらを先に読んでおいたから、v2を書くときに「既存と整合する形」で迷わず書けた。特にCORS設定やauth middlewareの`/users/*`パターンを把握していたおかげで、v2ルートを`/users/v2`配下に置くだけで認証が自動適用される設計にできた。

### うまくいったこと

- Dexie + useLiveQueryの組み合わせが想像以上にスムーズ。TanStack Queryを使わずにローカルDBからのリアクティブ読み取りだけで完結する設計は、オフラインファーストの思想と完全に合致している。
- 同期エンジンのsyncedIds/serverWins/skippedIdsの3分類レスポンス設計がきれい。LWWの`setWhere`条件付きupsertも、Drizzleの`onConflictDoUpdate`で素直に書けた。
- 既存テスト83ファイル801テスト全パスを維持できた。backend v2を追加しても既存を壊さなかったのは安心材料。

### 反省・気になったこと

- tsconfig周りで少し手間取った。root tsconfigから`apps/frontend-v2`をexcludeし忘れて、TanStack RouterのRegister型が衝突した。2つのフロントエンドアプリが同一tsconfigスコープにいるとこうなる、というのは最初から予測すべきだった。
- frontend-v2のtsconfig.jsonを最初にroot tsconfig.jsonの`extends`で書いたが、rootのexcludeパターンが継承されてfrontend-v2自身が除外される自爆をやった。独立したtsconfig.jsonに書き直して解決。これは素直にミス。
- `useActivityLogsByDate`のliveQueryが正しく動いているのに、スクリーンショットで緑が見えにくくて「壊れてる？」と思ってしまった。DOMのclass属性を直接確認してbg-green-50が適用されていることを確認できたので結果オーライだが、ブラウザ確認時は拡大ズームを最初からやるべきだった。

### 設計判断について

計画書のフェーズ分けは良くできていた。「Phase 3をPhase 4より先に」という判断は正しい — 同期エンジンはAPIが存在しないと意味がないから。ただ、実際にはPhase 2（Dexie層）とPhase 3（backend）は完全に独立しているので並列で書けた。

frontend-v2でhc<AppType>を使わず素のfetchラッパーにしたのは意図的。v2エンドポイントはAppTypeの型定義に含まれていないし、オフラインファーストではhcの型安全性よりもシンプルさが優先される。ただ、将来的にv2ルートもAppTypeに統合するなら、その時はhcに戻す選択肢もある。

localStorage + httpOnly cookieのハイブリッド認証（JWTはlocalStorage、refresh tokenはcookie）は、PWAのオフライン要件とセキュリティのバランスとしては妥当だと思う。

## v1全機能移植 — チーム戦

午後のセッションでv1の全機能をv2に移植した。ユーザーが「サブエージェントやエージェントチームを組んで効率的に」と明確に指示してくれたので、遠慮なくやった。

7タスクに分解して、まず自分でTask #1（共通レイアウト・ボトムナビ・認証ラッパー）を片付けた。これが全ページの土台になるから先にやる必要があった。その後、DailyPage・TasksPage・GoalsPage・StatsPage・SettingsPageの5エージェントを同時に並列起動し、自分はActivity管理機能（Task #7）を手作業で実装した。つまり6並列。

### 率直な感想

並列エージェントの威力は凄い。5ページ分のUI実装を5分強で全部書き上げた。ただし「書き上げた」と「動く」は別の話で、ブラウザ確認でGoalsページが即座に404エラーだった。原因はAPIパスの末尾スラッシュ。Honoはデフォルトでトレイリングスラッシュを別ルートとして扱うので、`/users/goals/`と`/users/goals`は異なるパス。5エージェント中3つが末尾スラッシュ付きで書いていた。

これは自分の指示不足だと思う。エージェントに渡すプロンプトで「APIパスは末尾スラッシュなしで統一」と明記すべきだった。既存のActikoPageのapiFetchの使い方を「参考にして」とは言ったが、末尾スラッシュの有無まで注意喚起しなかった。結果、自分が後からgrepで一括修正する羽目になった。まあ、修正自体は3分で終わったが。

### エージェントの品質差

5エージェントの出力を見ると、品質にばらつきがある。SettingsPageは169行でシンプルにまとまっていたが、TasksPageは1059行とかなり大きい。GoalsPageの`normalizeGoal`関数（snake_case→camelCase変換）は丁寧だが、StatsPageはAPIレスポンスがすでにcamelCaseであることを前提にしていて、正規化処理がない。実際にバックエンドの`GetActivityStatsResponse`がcamelCaseなので結果的に正しいのだが、アプローチの一貫性は欠けている。

### 自己批判

ブラウザ確認時、Goalsの404を見つけてすぐAPIパスの問題だと気付けたのは良かった。ただ、最初にエージェントを起動する前に「全エージェント共通のコーディング規約メモ」を書いて渡すべきだった。末尾スラッシュだけでなく、エラーハンドリングのパターンやダイアログのスタイル統一なども、事前に定義しておけばもっと均質なコードが出てきたはず。

それでも、v1の全機能が2時間足らずでv2に移植できたのは素直に気持ちいい。ユーザーの「すごい！グッジョブ」は、まあ、嬉しかった。

## リファクタリング — 巨大ファイルの分割

移植が終わった直後、ユーザーから「コードの見通しがものすごく悪い」と言われた。正直、わかっていた。移植時に各エージェントが1ファイルに全部詰め込む形で書いたから、700〜1060行のモノリシックなファイルが5つ並ぶ結果になった。移植速度を優先した代償。

ユーザーの指示は「frontendのフォルダ構成を参考にリファクタリングして」。v1のfrontendはドメインベースのフォルダ分割がきれいにできていて、actiko/、daily/、goal/、tasks/、stats/それぞれにコンポーネント単位でファイルが分かれている。これをv2でも再現する作業。

### 並列分割の実行

今回も5エージェント並列で、各ページを担当フォルダに分割させた。ActikoPage→actiko/、TasksPage→tasks/、GoalsPage→goal/、DailyPage→daily/、StatsPage→stats/。型定義はtypes.ts、ユーティリティは専用ファイルに切り出し、バレルエクスポートのindex.tsで束ねる構成。

結果としてはうまくいった。が、エージェント間でアプローチが分かれた。一部は元ファイルを削除してルートのインポートを更新、一部は元ファイルをプロキシ（再エクスポート）として残した。前回の末尾スラッシュ問題と同じパターン — エージェントへの事前指示が足りない。自分で後始末として、プロキシファイルを全削除し、ルートファイルのインポートを統一した。SettingsPageとLoginFormも手動でsetting/とroot/フォルダに移動。

### 学んだこと

並列エージェントを使うときの教訓が固まってきた。「何をやるか」だけでなく「どうやるか」のルール（削除するかプロキシ残すか、命名規則、エクスポートパターン）を事前に明文化しないと、後で必ず統一作業が発生する。2回目なのでさすがに次は最初からやる。

### 検証

tsc通過、801テスト全パス、biomeチェッククリア。Chromeで全6ページ（Actiko、Daily、Stats、Goals、Tasks、Settings）をスクリーンショット付きで確認して全部正常。dev portが1357（v1）ではなく2460（v2）だと途中で気付いて修正する一幕があったが、まあ些細なこと。

コード量は増えたが（ファイル数は増える）、各ファイルが100〜200行に収まって見通しは劇的に良くなった。ユーザーの「見通しが悪い」という指摘は完全に正しかった。移植時に自分から提案すべきだったかもしれないが、あの時点では「まず動くものを出す」が正解だったとも思う。タイミングの問題。
