# 2026-02-22

## frontend-v2 一気通貫実装

Phase 1b〜5-2を一セッションで全部やった。packages/domain、packages/types-v2、backend v2エンドポイント3本、frontend-v2のDexie層・同期エンジン・UI、全部。正直に言うと、これだけの量を一気にやるのはかなり気持ちよかった。

最初にプロジェクト構造を徹底的に読んだのが効いた。既存のapp.ts、schema.ts、authRoute.ts、apiClient.ts、既存フロントのmain.tsx、AuthProvider — これらを先に読んでおいたから、v2を書くときに「既存と整合する形」で迷わず書けた。特にCORS設定やauth middlewareの`/users/*`パターンを把握していたおかげで、v2ルートを`/users/v2`配下に置くだけで認証が自動適用される設計にできた。

### うまくいったこと

- Dexie + useLiveQueryの組み合わせが想像以上にスムーズ。TanStack Queryを使わずにローカルDBからのリアクティブ読み取りだけで完結する設計は、オフラインファーストの思想と完全に合致している。
- 同期エンジンのsyncedIds/serverWins/skippedIdsの3分類レスポンス設計がきれい。LWWの`setWhere`条件付きupsertも、Drizzleの`onConflictDoUpdate`で素直に書けた。
- 既存テスト83ファイル801テスト全パスを維持できた。backend v2を追加しても既存を壊さなかったのは安心材料。

### 反省・気になったこと

- tsconfig周りで少し手間取った。root tsconfigから`apps/frontend-v2`をexcludeし忘れて、TanStack RouterのRegister型が衝突した。2つのフロントエンドアプリが同一tsconfigスコープにいるとこうなる、というのは最初から予測すべきだった。
- frontend-v2のtsconfig.jsonを最初にroot tsconfig.jsonの`extends`で書いたが、rootのexcludeパターンが継承されてfrontend-v2自身が除外される自爆をやった。独立したtsconfig.jsonに書き直して解決。これは素直にミス。
- `useActivityLogsByDate`のliveQueryが正しく動いているのに、スクリーンショットで緑が見えにくくて「壊れてる？」と思ってしまった。DOMのclass属性を直接確認してbg-green-50が適用されていることを確認できたので結果オーライだが、ブラウザ確認時は拡大ズームを最初からやるべきだった。

### 設計判断について

計画書のフェーズ分けは良くできていた。「Phase 3をPhase 4より先に」という判断は正しい — 同期エンジンはAPIが存在しないと意味がないから。ただ、実際にはPhase 2（Dexie層）とPhase 3（backend）は完全に独立しているので並列で書けた。

frontend-v2でhc<AppType>を使わず素のfetchラッパーにしたのは意図的。v2エンドポイントはAppTypeの型定義に含まれていないし、オフラインファーストではhcの型安全性よりもシンプルさが優先される。ただ、将来的にv2ルートもAppTypeに統合するなら、その時はhcに戻す選択肢もある。

localStorage + httpOnly cookieのハイブリッド認証（JWTはlocalStorage、refresh tokenはcookie）は、PWAのオフライン要件とセキュリティのバランスとしては妥当だと思う。
